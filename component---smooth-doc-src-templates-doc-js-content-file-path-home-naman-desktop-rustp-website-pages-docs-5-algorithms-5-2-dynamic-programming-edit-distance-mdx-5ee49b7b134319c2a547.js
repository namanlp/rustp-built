"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6199],{42297:function(e,n,t){t.r(n),t.d(n,{default:function(){return o}});var r=t(27378),a=t(20951),i=t(88957);function l(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",ol:"ol",li:"li",code:"code",strong:"strong",h3:"h3",pre:"pre",blockquote:"blockquote"},(0,a.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h1,{id:"edit-distance--cses--problem",style:{position:"relative"}},r.createElement(n.a,{href:"#edit-distance--cses--problem","aria-label":"edit distance  cses  problem permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Edit Distance ( CSES ) Problem"),"\n",r.createElement(n.p,null,"and space optimized Dynamic Programming Solution using tabulation and memoization in Rust Language."),"\n",r.createElement(n.h2,{id:"introduction",style:{position:"relative"}},r.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",r.createElement(n.p,null,"Edit distance is another very commonly seen Dynamic Programming Problem and is very similar to ",r.createElement(n.a,{href:"/dynamic-programming/longest-common-subsequence/"},"Longest Common Subsequence Problem"),"."),"\n",r.createElement(n.p,null,"In this problem, we have to determine minimum number of operations required to transform one string into the other."),"\n",r.createElement(n.p,null,"Now, the operations allowed are different for different websites or problems. We are solving ",r.createElement(n.a,{href:"https://cses.fi/problemset/task/1639"},"CSES Edit Distance")," problem in this article."),"\n",r.createElement(n.p,null,"In this problem, allowed operations are"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"Add one character to the string."),"\n",r.createElement(n.li,null,"Remove one character from the string."),"\n",r.createElement(n.li,null,"Replace one character in the string."),"\n"),"\n",r.createElement(n.p,null,"For example, strings are ",r.createElement(n.code,null,"ABC")," and ",r.createElement(n.code,null,"XYA"),". For this, answer should be ",r.createElement(n.strong,null,"3"),", because you can simply replace each character."),"\n",r.createElement(n.h2,{id:"observation",style:{position:"relative"}},r.createElement(n.a,{href:"#observation","aria-label":"observation permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Observation"),"\n",r.createElement(n.p,null,"The observation tells us that either the last character of string matches, or does not matches."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"1. Last character of string is same :")," Then, we do not have to change it. We can simply solve the answer for n-1 and m-1 length strings. It can be proved it is always optimal."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"2. Last character of string is not same :")," Then we can perform either of 3 operations, and take minimum of them. It requires 1 operation."),"\n",r.createElement(n.h2,{id:"recursive-solution",style:{position:"relative"}},r.createElement(n.a,{href:"#recursive-solution","aria-label":"recursive solution permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Recursive Solution"),"\n",r.createElement(n.p,null,"Recursive solution to this problem should be pretty straightforward now."),"\n",r.createElement(n.h3,{id:"algorithm",style:{position:"relative"}},r.createElement(n.a,{href:"#algorithm","aria-label":"algorithm permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"If either of string is empty, ",r.createElement(n.strong,null,"return length of other string"),". Because, you have to either add all the characters or remove all the characters, depending on which string is empty."),"\n",r.createElement(n.li,null,"If the last character is same, simply return the function for strings of n-1 and m-1 length. This requires no operation."),"\n",r.createElement(n.li,null,"Otherwise, return 1 + minimum of all three operations."),"\n"),"\n",r.createElement(n.h3,{id:"function",style:{position:"relative"}},r.createElement(n.a,{href:"#function","aria-label":"function permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.p,null,"Here is the function using above algorithm"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Note :")," In Rust Language, the ",r.createElement(n.code,null,"String")," is UTF-8 encoded by default, hence, indexing is not possible in ",r.createElement(n.code,null,"String")," type. Hence, we use ",r.createElement(n.strong,null,r.createElement(n.code,null,"Vec<char>"))," instead."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize) -> usize{\n\n    // If either of string is empty, return length of other string\n    if n==0 || m==0 {\n        return n+m;\n    }\n\n    // If the character is same, we don't have to change it\n    // And skip the character\n    if str1[n-1] == str2[m-1] {\n        return edit_distance(str1, str2, n-1, m-1);\n    }\n\n    // Else, we check all the 3 possibilities,\n    // Return minimum of them as answer\n\n    return 1+ min(\n        min(\n        // 1. If we add character, we can skip this character from\n        // string 2, because, string 1 and 2 has same last character now\n        edit_distance(str1, str2, n, m-1),\n\n        // 2. If we remove the character, we skip it from string 1\n        edit_distance(str1, str2, n-1, m)),\n\n        // 3. If we replace, both string 1 and 2 have same last character\n        edit_distance(str1, str2, n-1, m-1)\n    );\n}\n")),"\n",r.createElement(n.p,null,"With driver code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'\n\nfn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize) -> usize{\n\n    // If either of string is empty, return length of other string\n    if n==0 || m==0 {\n        return n+m;\n    }\n\n    // If the character is same, we don\'t have to change it\n    // And skip the character\n    if str1[n-1] == str2[m-1] {\n        return edit_distance(str1, str2, n-1, m-1);\n    }\n\n    // Else, we check all the 3 possibilities,\n    // Return minimum of them as answer\n\n    return 1+ min(\n        min(\n        // 1. If we add character, we can skip this character from\n        // string 2, because, string 1 and 2 has same last character now\n        edit_distance(str1, str2, n, m-1),\n\n        // 2. If we remove the character, we skip it from string 1\n        edit_distance(str1, str2, n-1, m)),\n\n        // 3. If we replace, both string 1 and 2 have same last character\n        edit_distance(str1, str2, n-1, m-1)\n    );\n}\n\n\n// Driver Code\nuse std::io::stdin;\nuse std::cmp::min;\n\nfn take_string() -> Vec<char> {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    let vec:Vec<char> = input.trim().chars().collect();\n    return vec;\n}\n\nfn main() {\n    let str1 = take_string();\n    let str2 = take_string();\n\n    println!("{}", edit_distance(&str1, &str2, str1.len(), str2.len()));\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"ABC ",r.createElement("br"),"\nXYA"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"3"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( 3",r.createElement("sup",null,"m+n")," )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( m+n )")),"\n",r.createElement(n.p,null,"( Space complexity includes recursive stack space )"),"\n",r.createElement(n.h2,{id:"overlapping-sub-problems",style:{position:"relative"}},r.createElement(n.a,{href:"#overlapping-sub-problems","aria-label":"overlapping sub problems permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overlapping Sub-problems"),"\n",r.createElement(n.p,null,"If we have a look carefully on recursive approach, we computed multiple results many times."),"\n",r.createElement(n.p,null,"For example, if the strings are ABCDEFG and MNOPQRST, the result for substrings ABC and MNOP is computed hundreds of times, and take hundreds of recursions each time.\nThese are called overlapping sub-problems, because it is a sub-problem of actual problem and is overlapping in multiple recursions."),"\n",r.createElement(n.p,null,"To prevent this, we can store the output and each result will be calculated only once."),"\n",r.createElement(n.p,null,"In Edit Distance problem, we can create a dp matrix, and store each value by lengths of first and second string. That is, answer for ABC and MNOP will be stored at dp[3][4]."),"\n",r.createElement(n.p,null,"This is called memoization or Top-down Dynamic Programming."),"\n",r.createElement(n.h2,{id:"memoization--top-down-dp--method",style:{position:"relative"}},r.createElement(n.a,{href:"#memoization--top-down-dp--method","aria-label":"memoization  top down dp  method permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memoization ( Top-down DP ) Method"),"\n",r.createElement(n.p,null,"In memoization method, we simply take a DP matrix, and store the computed result."),"\n",r.createElement(n.h3,{id:"algorithm-1",style:{position:"relative"}},r.createElement(n.a,{href:"#algorithm-1","aria-label":"algorithm 1 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"First, take a dp matrix of size (n+1) × (m+1) and set all elements to None."),"\n",r.createElement(n.li,null,"If the now, if the value for given n and m is already stored, return it."),"\n",r.createElement(n.li,null,"Else, calculate the value using recursion and store it in the matrix and return it."),"\n"),"\n",r.createElement(n.h3,{id:"function-1",style:{position:"relative"}},r.createElement(n.a,{href:"#function-1","aria-label":"function 1 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.p,null,"Here is the function using above algorithm"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"\n\nfn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize, dp : &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    // If either of string is empty, return length of other string\n    if n==0 || m==0 {\n        return n+m;\n    }\n\n    // If result is already calculated, return it\n    if dp[n][m].is_some() { return dp[n][m].unwrap(); }\n\n    // If the character is same, we don't have to change it\n    // And skip the character. Store and return it\n    if str1[n-1] == str2[m-1] {\n        dp[n][m] = Option::from(edit_distance(str1, str2, n-1, m-1, dp));\n        return dp[n][m].unwrap();\n    }\n\n    // Else, we check all the 3 possibilities,\n    // Return minimum of them as answer\n\n    dp[n][m] = Option::from(1+min(\n        min(\n            // 1. If we add character, we can skip this character from\n            // string 2, because, string 1 and 2 has same last character now\n            edit_distance(str1, str2, n, m-1, dp),\n\n            // 2. If we remove the character, we skip it from string 1\n            edit_distance(str1, str2, n-1, m, dp)),\n\n        // 3. If we replace, both string 1 and 2 have same last character\n        edit_distance(str1, str2, n-1, m-1, dp)\n    ));\n\n    return dp[n][m].unwrap();\n}\n")),"\n",r.createElement(n.p,null,"With driver code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'\n\nfn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize, dp : &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    // If either of string is empty, return length of other string\n    if n==0 || m==0 {\n        return n+m;\n    }\n\n    // If result is already calculated, return it\n    if dp[n][m].is_some() { return dp[n][m].unwrap(); }\n\n    // If the character is same, we don\'t have to change it\n    // And skip the character. Store and return it\n    if str1[n-1] == str2[m-1] {\n        dp[n][m] = Option::from(edit_distance(str1, str2, n-1, m-1, dp));\n        return dp[n][m].unwrap();\n    }\n\n    // Else, we check all the 3 possibilities,\n    // Return minimum of them as answer\n\n    dp[n][m] = Option::from(1+min(\n        min(\n            // 1. If we add character, we can skip this character from\n            // string 2, because, string 1 and 2 has same last character now\n            edit_distance(str1, str2, n, m-1, dp),\n\n            // 2. If we remove the character, we skip it from string 1\n            edit_distance(str1, str2, n-1, m, dp)),\n\n        // 3. If we replace, both string 1 and 2 have same last character\n        edit_distance(str1, str2, n-1, m-1, dp)\n    ));\n\n    return dp[n][m].unwrap();\n}\n\n\n// Driver Code\nuse std::io::stdin;\nuse std::cmp::min;\n\nfn take_string() -> Vec<char> {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    let vec:Vec<char> = input.trim().chars().collect();\n    return vec;\n}\n\nfn main() {\n    let str1 = take_string();\n    let str2 = take_string();\n\n    let mut dp = vec![vec![None; str2.len()+1]; str1.len()+1];\n\n    println!("{}", edit_distance(&str1, &str2, str1.len(), str2.len(), &mut dp));\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"ABC ",r.createElement("br"),"\nXYA"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"3"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( m×n )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( m×n )")),"\n",r.createElement(n.h2,{id:"tabulation---bottom-up-dp---method",style:{position:"relative"}},r.createElement(n.a,{href:"#tabulation---bottom-up-dp---method","aria-label":"tabulation   bottom up dp   method permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tabulation  ( Bottom-up DP )  Method"),"\n",r.createElement(n.p,null,"Although time and space complexities of tabulation as well as memoization method are same, tabulation is much more efficient as there are a lot of expensive recursive calls in memoization."),"\n",r.createElement(n.p,null,"In tabulation method, we make the matrix, and fill it first on the basis of base condition, and then on the basis of previous row."),"\n",r.createElement(n.h3,{id:"algorithm-2",style:{position:"relative"}},r.createElement(n.a,{href:"#algorithm-2","aria-label":"algorithm 2 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"Firstly, for the first row, set the value of each cell of the matrix as corresponding column number, because if length of string1 is 0, the answer is length of string2. Similarly, fill the first column."),"\n",r.createElement(n.li,null,"Now, traverse the matrix row wise ( or column wise, as per your preference ), and if the given character of both strings is same, set the dp[i][j] as dp[i-1][j-1]."),"\n",r.createElement(n.li,null,"Else, set the element as 1 + minimum of all three previous elements, that is, dp[i-1][j], dp[i-1][j-1] and dp[i][j-1]."),"\n",r.createElement(n.li,null,"Finally, return the last value of matrix, that is, dp[n][m]."),"\n"),"\n",r.createElement(n.h3,{id:"function-2",style:{position:"relative"}},r.createElement(n.a,{href:"#function-2","aria-label":"function 2 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.p,null,"Here is the function using above algorithm"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize) -> usize{\n\n    // Create a dp matrix\n    let mut dp = vec![vec![0; str2.len()+1]; str1.len()+1];\n\n    // Set the first row as corresponding column number\n    for i in 1..str2.len()+1 {\n        dp[0][i]=i;\n    }\n\n    // Set the first column as corresponding row number\n    for i in 1..str1.len()+1 {\n        dp[i][0] = i;\n    }\n\n    // Now, traverse the matrix for each row and column.\n\n    for i in 1..str1.len()+1 {\n        for j in 1..str2.len()+1 {\n\n            // If the character is same, just copy dp[i-1][j-1]\n\n            if str1[i-1] == str2[j-1] { dp[i][j] = dp[i-1][j-1]; }\n\n            // Else, set it to 1 + minimum of previous 3 cells\n            else {\n                dp[i][j] = 1 + min(dp[i][j-1],\n                    min(dp[i-1][j], dp[i-1][j-1]));\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n")),"\n",r.createElement(n.p,null,"With Driver code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'\n\nfn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize) -> usize{\n\n    // Create a dp matrix\n    let mut dp = vec![vec![0; str2.len()+1]; str1.len()+1];\n\n    // Set the first row as corresponding column number\n    for i in 1..str2.len()+1 {\n        dp[0][i]=i;\n    }\n\n    // Set the first column as corresponding row number\n    for i in 1..str1.len()+1 {\n        dp[i][0] = i;\n    }\n\n    // Now, traverse the matrix for each row and column.\n\n    for i in 1..str1.len()+1 {\n        for j in 1..str2.len()+1 {\n\n            // If the character is same, just copy dp[i-1][j-1]\n\n            if str1[i-1] == str2[j-1] { dp[i][j] = dp[i-1][j-1]; }\n\n            // Else, set it to 1 + minimum of previous 3 cells\n            else {\n                dp[i][j] = 1 + min(dp[i][j-1],\n                    min(dp[i-1][j], dp[i-1][j-1]));\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\n\n// Driver Code\nuse std::io::stdin;\nuse std::cmp::min;\n\nfn take_string() -> Vec<char> {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    let vec:Vec<char> = input.trim().chars().collect();\n    return vec;\n}\n\nfn main() {\n    let str1 = take_string();\n    let str2 = take_string();\n\n    println!("{}", edit_distance(&str1, &str2, str1.len(), str2.len()));\n}\n\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"ABC ",r.createElement("br"),"\nXYA"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"3"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( m×n )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( m×n )")),"\n",r.createElement(n.h2,{id:"space-optimized-tabulation-method",style:{position:"relative"}},r.createElement(n.a,{href:"#space-optimized-tabulation-method","aria-label":"space optimized tabulation method permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Space Optimized Tabulation Method"),"\n",r.createElement(n.p,null,"If we observe the above tabulation method carefully, we find that for calculating edit distance for two strings, only ",r.createElement(n.strong,null,"current and previous row")," are required."),"\n",r.createElement(n.p,null,"Hence, we can optimize our space complexity, by storing only the previous row instead of the whole matrix."),"\n",r.createElement(n.h3,{id:"function-3",style:{position:"relative"}},r.createElement(n.a,{href:"#function-3","aria-label":"function 3 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.p,null,"Here is the function using space optimization of tabulation method."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize) -> usize{\n\n    // Create a dp matrix\n    let mut prev = vec![0; m+1];\n    let mut curr = vec![0; m+1];\n\n    // Set the first row as corresponding column number\n    for i in 1..m+1 {\n        prev[i] = i;\n    }\n\n\n    // Now, traverse for each character of  both the strings.\n\n    for i in 1..n+1 {\n        // Set current's first element as corresponding row number\n        curr[0] = i;\n\n        // Now traverse for each column in given row\n        for j in 1..m+1 {\n\n            // If the character is same, just copy previous[j-1]\n            if str1[i-1] == str2[j-1] { curr[j] = prev[j-1]; }\n\n            // Else, set it to 1 + minimum of previous 3 cells\n            else {\n                curr[j] = 1 + min(curr[j-1],\n                    min(prev[j], prev[j-1]));\n            }\n        }\n\n        // Now, copy current row to previous row\n        // No need to reinitialise current row,\n        // Because we are not using those values\n        prev=curr.clone();\n    }\n\n    return curr[m];\n}\n")),"\n",r.createElement(n.p,null,"Use the same driver code."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"ABC ",r.createElement("br"),"\nXYA"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"3"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( m×n )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( m )")),"\n",r.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},r.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",r.createElement(n.p,null,"Edit distance is very commonly seen Dynamic Programming Problem and is very similar to ",r.createElement(n.a,{href:"/dynamic-programming/longest-common-subsequence/"},"Longest Common Subsequence Problem"),"."),"\n",r.createElement(n.p,null,"In this problem, we have to determine minimum number of operations required to transform one string into the other."),"\n",r.createElement(n.p,null,"In this article, we saw how to solve the  ",r.createElement(n.a,{href:"https://cses.fi/problemset/task/1639"},"CSES Edit Distance"),", first using recursion and then using Dynamic Programming, memoization as well as tabulation method, and latter the space optimized tabulation method in Rust Language."),"\n",r.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn edit_distance(str1:&Vec<char>, str2:&Vec<char>, n:usize, m:usize) -> usize{\n    let mut prev = vec![0; m+1];\n    let mut curr = vec![0; m+1];\n    for i in 1..m+1 { prev[i] = i; }\n    for i in 1..n+1 {\n        curr[0] = i;\n        for j in 1..m+1 {\n            if str1[i-1] == str2[j-1] { curr[j] = prev[j-1]; }\n            else {\n                curr[j] = 1 + min(curr[j-1],\n                    min(prev[j], prev[j-1])); } }\n        prev=curr.clone();\n    }\n    return curr[m];\n}\n")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Thank You")),"\n","\n",r.createElement(i.H,{title:"Edit Distance (CSES) with Space Optimization - DP - Rust Programming",description:"Tell minimum operations to transform one string to the other. We will see recursive, memoization, tabulation and space optimized DP solution in Rust Language.",img:"https://rustp.org/Static_Images_DND/Social/Edit_Distance.png"}))}var s=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?r.createElement(n,e,r.createElement(l,e)):l(e)};function c(e){return e.children}function o(e){return r.createElement(c,e,r.createElement(s,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-2-dynamic-programming-edit-distance-mdx-5ee49b7b134319c2a547.js.map