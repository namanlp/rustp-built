"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[39],{87970:function(e,n,t){t.r(n),t.d(n,{default:function(){return s}});var l=t(27378),r=t(20951),a=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",ol:"ol",li:"li",strong:"strong",pre:"pre",code:"code",blockquote:"blockquote"},(0,r.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.h1,{id:"searching-in-a-vector",style:{position:"relative"}},l.createElement(n.a,{href:"#searching-in-a-vector","aria-label":"searching in a vector permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Searching in a vector"),"\n",l.createElement(n.p,null,"and program for linear and binary search in a vector Rust"),"\n",l.createElement(n.h2,{id:"introduction",style:{position:"relative"}},l.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",l.createElement(n.p,null,"Searching is finding the index of an element in a collection of elements. Here, in this article, we will discuss how to search for a given element in a vector."),"\n",l.createElement(n.p,null,"We can search for an element in a vector ar an array in 2 possible ways"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Linear Search :")," In this, we traverse through whole vector till the element is found. Hence, it takes ",l.createElement(n.strong,null,"O( n )")," time complexity."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Binary Search :")," In this, we only check mid-points instead of checking the whole vector. Hence, it takes only ",l.createElement(n.strong,null,"O( log(n) )")," time complexity. Vector must be sorted for Binary Search."),"\n"),"\n",l.createElement(n.h2,{id:"linear-search",style:{position:"relative"}},l.createElement(n.a,{href:"#linear-search","aria-label":"linear search permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Linear Search"),"\n",l.createElement(n.p,null,"In the Linear Search, we traverse the whole vector, and check if the given element is equal to key. If the element is found, its index is returned."),"\n",l.createElement(n.p,null,"As it traverses the whole array, it takes ",l.createElement(n.strong,null,"O( n )")," time complexity."),"\n",l.createElement(n.p,null,"Also, ",l.createElement(n.strong,null,"order of array does not matter")," for linear search. It is very simple to implement. Here is a simple function demonstrating Linear Search"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"fn search(vecky:&Vec<usize>, key:usize) -> usize{\n    for i in 0..vecky.len() {\n        if vecky[i] == key {\n            return i;\n        }\n    }\n\n    // If element is not found\n    return vecky.len();\n}\n")),"\n",l.createElement(n.p,null,"Program With driver code"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},'fn search(vecky:&Vec<usize>, key:usize) -> usize{\n    for i in 0..vecky.len() {\n        if vecky[i] == key {\n            return i;\n        }\n    }\n\n    // If element is not found\n    return vecky.len();\n}\n\n// Driver code\n\nfn main() {\n    let vecky = vec![0, 1, 2, 3, 4, 5];\n    println!("{}", search(&vecky, 4) );\n    println!("{}", search(&vecky, 100) );\n}\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"4 ",l.createElement("br"),"\n6"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Time Complexity : O( n )")," ",l.createElement("br"),"\n",l.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",l.createElement(n.p,null,"The standard crate in Rust only has ",l.createElement(n.code,null,"binary_search()")," and ",l.createElement(n.code,null,"contains()")," function. So, you will have to make your own search function for Linear Search, as above"),"\n",l.createElement(n.h2,{id:"binary-search",style:{position:"relative"}},l.createElement(n.a,{href:"#binary-search","aria-label":"binary search permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Binary Search"),"\n",l.createElement(n.p,null,"In the Binary Search, we only check the midpoints of a ",l.createElement(n.strong,null,"sorted list"),". Each time, we have to search only in half of the list. Hence, its complexity is ",l.createElement(n.strong,null,"O( log(n) )"),"."),"\n",l.createElement(n.p,null,"Also, the vector ",l.createElement(n.strong,null,"must be sorted")," for Binary search."),"\n",l.createElement(n.p,null,"Here is the Algorithm"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"Calculate the mid-point of the ",l.createElement(n.strong,null,"sorted")," vector."),"\n",l.createElement(n.li,null,"If the element is equal to the mid-point, return the index of the mid-point."),"\n",l.createElement(n.li,null,"If the Element is greater than the mid-point, search for the element in the slice containing the larger values."),"\n",l.createElement(n.li,null,"If the element is less than the mid-point, search the elements in slice containing smaller values than the mid-point."),"\n",l.createElement(n.li,null,"Go back to step 2, till we have no elements left in the slice."),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Note :")," If we observe carefully, each time if the element is not found, we have to find for the element in only the half of the vector. So, it takes only ",l.createElement(n.strong,null,"O ( log(n) )")," for finding any element."),"\n",l.createElement(n.p,null,"Here is the function for Binary Search in Rust"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"fn binary_search(vecky:&Vec<usize>, key:usize) -> usize{\n    let mut low = 0;\n    let mut high = vecky.len()-1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n\n        // If key is middle element, return it\n        if vecky[mid] == key {\n            return mid;\n        }\n\n        // If key is greater than middle element, we ignore left half\n        if vecky[mid] < key {\n            low = mid + 1;\n        }\n\n        // If key is less than middle element, we ignore right half\n        else{\n            high = mid - 1;\n        }\n    }\n    // If the element is not found\n    return vecky.len();\n}\n")),"\n",l.createElement(n.p,null,"Use the same driver code."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"4 ",l.createElement("br"),"\n6"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Time Complexity : O( log(n) )")," ",l.createElement("br"),"\n",l.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",l.createElement(n.h2,{id:"binary_search-function",style:{position:"relative"}},l.createElement(n.a,{href:"#binary_search-function","aria-label":"binary_search function permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"binary_search() function"),"\n",l.createElement(n.p,null,"Rust already has ",l.createElement(n.strong,null,l.createElement(n.code,null,"binary_search()"))," function built into it. It is already there in ",l.createElement(n.code,null,"std::vec::Vec")," and hence, included in prelude. So, you don't even have to import it explicitly."),"\n",l.createElement(n.p,null,"For example,"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},'fn main() {\n    let vecky = vec![0, 1, 2, 3, 4, 5];\n    println!("{}", vecky.binary_search(&4).expect("Not found") );\n    println!("{}", vecky.binary_search( &100).expect("Not Found") );\n}\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"4 ",l.createElement("br"),"\nthread 'main' panicked at 'Not Found: 6'"),"\n"),"\n",l.createElement(n.p,null,"Hence, you can easily use ",l.createElement(n.code,null,"binary_search()")," function on any vector or  a slice of vector in Rust."),"\n",l.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},l.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",l.createElement(n.p,null,"Searching is an important operation in a Vector. In this article, we discussed Linear Search as well as Binary Search and saw their programs and also how to use built-in function to perform Search in Rust."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Thank You")),"\n","\n",l.createElement(a.H,{title:"Searching in a Vector - Rust Programming",description:"Searching is an important operation in a Vector. In this article, we will discuss Linear Search as well as Binary Search and see their programs and also how to use built-in function to perform Search in Rust"}))}var c=function(e){void 0===e&&(e={});var n=Object.assign({},(0,r.ah)(),e.components).wrapper;return n?l.createElement(n,e,l.createElement(i,e)):i(e)};function o(e){return e.children}function s(e){return l.createElement(o,e,l.createElement(c,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-4-data-structures-vector-searching-mdx-dddb72e76f8b418f0d94.js.map