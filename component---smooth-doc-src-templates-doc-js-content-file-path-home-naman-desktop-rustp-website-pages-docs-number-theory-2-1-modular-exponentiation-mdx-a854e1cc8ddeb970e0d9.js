"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[101],{9555:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var l=t(27378),a=t(20951),r=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",code:"code",pre:"pre",blockquote:"blockquote",h3:"h3",ol:"ol",li:"li"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.h1,{id:"modular-exponentiation-in-rust",style:{position:"relative"}},l.createElement(n.a,{href:"#modular-exponentiation-in-rust","aria-label":"modular exponentiation in rust permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Modular Exponentiation in Rust"),"\n",l.createElement(n.p,null,"And its Program in Rust"),"\n",l.createElement(n.h2,{id:"what-is-modular-exponentiation",style:{position:"relative"}},l.createElement(n.a,{href:"#what-is-modular-exponentiation","aria-label":"what is modular exponentiation permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"What is Modular Exponentiation"),"\n",l.createElement(n.p,null,"Many times, we have to compute exponents of a given number for various purposes. But it is notable that overflow may occur for large values. Largest number that we can store with numerical data type in rust is ",l.createElement(n.strong,null,l.createElement(n.code,null,"2¹²⁸")),", and is 2",l.createElement("sup",null,"64")," in C / C++."),"\n",l.createElement(n.p,null,"Now, suppose, in some question, we have to find ",l.createElement(n.strong,null,l.createElement(n.code,null,"2¹⁰⁰⁰"))," modulo 1000000007. If we try to first compute ",l.createElement(n.strong,null,l.createElement(n.code,null,"2¹⁰⁰⁰"))," and then find modulo, rust will throw overflow error."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},"thread 'main' panicked at 'attempt to multiply with overflow', src/iterative.rs:10:9\n")),"\n",l.createElement(n.h2,{id:"problem-statement",style:{position:"relative"}},l.createElement(n.a,{href:"#problem-statement","aria-label":"problem statement permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Problem statement"),"\n",l.createElement(n.p,null,"Given three numbers n, x and p, compute n",l.createElement("sup",null,"x"),"  modulo p."),"\n",l.createElement(n.h2,{id:"naive-approach",style:{position:"relative"}},l.createElement(n.a,{href:"#naive-approach","aria-label":"naive approach permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Naive Approach"),"\n",l.createElement(n.p,null,"Simplest solution to this would be to take 1, and multiply it with n, x times, and find modulo p each time. From ",l.createElement(n.a,{href:"/number-theory/modular-multiplication/#2-multiplication-property"},"Modular Multiplication"),", we already know that"),"\n",l.createElement("center",null," ",l.createElement("b",null,"(a x b) mod m = ((a mod m) x (b mod m)) mod m")," "),"\n",l.createElement(n.p,null,"But this will be done in ",l.createElement(n.strong,null,"O( x )")," or ",l.createElement(n.strong,null,"Linear time complexity.")),"\n",l.createElement(n.p,null,"Here's the code for this approach"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"fn modular_exponent(n:i128 , x:i128 , p:i128) -> i128{\n    // Initialize ans = 1\n    let mut ans = 1;\n\n    // Multiply ans with n, x times, ans modulo\n    for _ in 0..x {\n        ans *= n;\n        ans%=p;\n    }\n\n    // Return ans\n    return ans;\n}\n")),"\n",l.createElement(n.p,null,"With Driver Code"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},'fn modular_exponent(n:i128 , x:i128 , p:i128) -> i128{\n    // Initialize ans = 1\n    let mut ans = 1;\n\n    // Multiply ans with n, x times, ans modulo\n    for _ in 0..x {\n        ans *= n;\n        ans%=p;\n    }\n\n    // Return ans\n    return ans;\n}\n\n// Driver Code\n\nuse std::io;\n\nfn take_int() -> i128 {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    return input.trim().parse().unwrap();\n}\n\nfn main() {\n    let n = take_int();\n    let x = take_int();\n    let p = take_int();\n\n    println!("{}", modular_exponent(n, x, p));\n}\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Input")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"2 ",l.createElement("br"),"\n100000 ",l.createElement("br"),"\n1000000007 ",l.createElement("br")),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"607723520"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Time Complexity : O( x )")," ",l.createElement("br"),"\n",l.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement(n.h2,{id:"efficient-divide-and-conquer-solution",style:{position:"relative"}},l.createElement(n.a,{href:"#efficient-divide-and-conquer-solution","aria-label":"efficient divide and conquer solution permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Efficient Divide and Conquer solution"),"\n",l.createElement(n.p,null,"We can find the modular exponentiation in logarithmic time complexity, using  Divide and Conqueror approach."),"\n",l.createElement(n.h3,{id:"approach",style:{position:"relative"}},l.createElement(n.a,{href:"#approach","aria-label":"approach permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approach"),"\n",l.createElement(n.p,null,"We know that mathematically,"),"\n",l.createElement("center",null," ",l.createElement("b",null," n",l.createElement("sup",null,"a.b")," = (n",l.createElement("sup",null,"a")," )",l.createElement("sup",null," b ")," ")," "),"\n",l.createElement(n.p,null,"So, let's suppose we have to find n",l.createElement("sup",null,"x")," and x = 2.y, so, we can find ( n ",l.createElement("sup",null," 2 ")," ) ",l.createElement("sup",null," y "),". ",l.createElement("br")," ",l.createElement(n.strong,null,"In y + 1 steps or x/2 + 1 steps")),"\n",l.createElement(n.p,null,l.createElement("center",null," ",l.createElement("b",null," n",l.createElement("sup",null,"2.y")," = (n",l.createElement("sup",null,"2")," )",l.createElement("sup",null," y ")," ")," "),"\nHence, we multiply n by itself, if x is even."),"\n",l.createElement(n.p,null,"If, on the other hand, x is odd number ",l.createElement(n.strong,null,"it is guaranteed that x-1 will be even number"),", hence, we multiply answer by n, if x is odd, and reduce x by 1."),"\n",l.createElement("hr"),"\n",l.createElement(n.h3,{id:"algorithm",style:{position:"relative"}},l.createElement(n.a,{href:"#algorithm","aria-label":"algorithm permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"If x <= 0, return 1."),"\n",l.createElement(n.li,null,"If x is 1, return (answer * n) % p"),"\n",l.createElement(n.li,null,"If x  > 1 and even, change n to n",l.createElement("sup",null,"2"),", change x to x/2, and go to step 2"),"\n",l.createElement(n.li,null,"If X > 1 and odd, multiply answer by n and store answer modulo p, and reduce x to x-1 and go to step 2."),"\n"),"\n",l.createElement(n.h2,{id:"program-for-modular-exponentiation-in-rust",style:{position:"relative"}},l.createElement(n.a,{href:"#program-for-modular-exponentiation-in-rust","aria-label":"program for modular exponentiation in rust permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Program for Modular Exponentiation in Rust"),"\n",l.createElement(n.p,null,"Implementation of above algorithm is written below"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"\nfn modular_exponent(mut n:i128 ,mut x:i128 , p:i128) -> i128{\n    // Initialize ans = 1\n    let mut ans = 1;\n\n    // x is 0, return 1\n    if x<=0 {\n        return 1;\n    }\n\n    // use loop statement in rust for infinite loop\n    loop {\n        // Step 2. If x is 1, return (answer * n) % p\n        if x==1 {\n            return (ans * n) % p;\n        }\n\n        // Step 3. If x > 1 and even, change n to n^2, change x to x/2, and go to step 2\n\n        // for checking if x is even, we check the LSB. is 0 or 1\n        // Alternatively, we can also check x%2, but this is more efficient\n        if x&1==0 {\n            n=( n * n ) % p;\n            x>>=1; // or x = x/2\n            continue;\n        }\n\n        // Step 4. If X > 1 and odd, multiply answer by n and store answer modulo p,\n        // and reduce x to x-1 and go to step 2.\n        else {\n            ans = (ans*n) % p;\n            x-=1;\n        }\n    }\n}\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Input")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"2 ",l.createElement("br"),"\n100000 ",l.createElement("br"),"\n1000000007 ",l.createElement("br")),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"607723520"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Time Complexity : O( log ",l.createElement("sub",null," 2 ")," x)")," ",l.createElement("br"),"\n",l.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",l.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},l.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",l.createElement(n.p,null,"Modular exponentiation is very frequently used concept in competitive programming for computing the answer.\nIn this article, we made a program for modular exponentiation in rust in logarithmic time complexity instead of linear time complexity using Divide and Conquer approach. Here's the function for easy access"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"\nfn modular_exponent(mut n:i128 ,mut x:i128 , p:i128) -> i128{\n    let mut ans = 1;\n    if x<=0 { return 1; }\n    loop {\n        if x==1 { return (ans * n) % p; }\n        if x&1==0 {\n            n=( n * n ) % p;\n            x>>=1;\n            continue;\n        }\n        else {\n            ans = (ans*n) % p;\n            x-=1;\n        }\n    }\n}\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Thank You")),"\n","\n",l.createElement(r.H,{title:"Modular Exponentiation - Rust Programming",description:"Modular exponentiation is very frequently used concept in competitive programming. Here is the program for modular exponentiation in rust in logarithmic time complexity instead of linear using Divide and Conquer"}))}var o=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?l.createElement(n,e,l.createElement(i,e)):i(e)};function c(e){return e.children}function u(e){return l.createElement(c,e,l.createElement(o,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-number-theory-2-1-modular-exponentiation-mdx-a854e1cc8ddeb970e0d9.js.map