"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[116],{88933:function(e,n,t){t.r(n),t.d(n,{default:function(){return c}});var a=t(27378),r=t(20951),l=t.p+"static/Kadane-83901d8c41188798ea1880bb70f73998.webp",i=t(88957);function s(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",strong:"strong",h2:"h2",pre:"pre",code:"code",blockquote:"blockquote",h3:"h3",ol:"ol",li:"li"},(0,r.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h1,{id:"maximum-subarray-sum",style:{position:"relative"}},a.createElement(n.a,{href:"#maximum-subarray-sum","aria-label":"maximum subarray sum permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Maximum Subarray Sum"),"\n",a.createElement(n.p,null,"in an array using ",a.createElement(n.strong,null,"Kadane’s Algorithm")," in Rust"),"\n",a.createElement(n.h2,{id:"problem-statement",style:{position:"relative"}},a.createElement(n.a,{href:"#problem-statement","aria-label":"problem statement permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Problem Statement"),"\n",a.createElement(n.p,null,"Given an array of numbers, say ",a.createElement(n.strong,null,"arr[]"),", containing both ",a.createElement(n.strong,null,"positive and negative elements"),", you have to find the largest sum of the subarray of ",a.createElement(n.strong,null,"arr[]"),"."),"\n",a.createElement(n.p,null,"Subarray is defined as ",a.createElement(n.strong,null,"contiguous")," part of the original array, containing one or more element. For example, for array [1, 2, 3], [1, 2] is subarray while [1, 3] is not."),"\n",a.createElement(n.p,null,"We have to find the largest  sum of all the subarray present in the given arr[]."),"\n","\n",a.createElement("div",{style:{textAlign:"center"}},a.createElement("img",{src:l,width:"100%",alt:"Maximum Subarray Sum"})),"\n",a.createElement(n.h2,{id:"naive-approach",style:{position:"relative"}},a.createElement(n.a,{href:"#naive-approach","aria-label":"naive approach permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Naive Approach"),"\n",a.createElement(n.p,null,"Naive or brute force approach is to find the sum of all the subarray and return the maximum of them. Function using this approach is"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn max_subarray_sum(arr : Vec<i128>) -> i128{\n\n    // it is not initialized to 0 because array can be all negative elements.\n    let mut max_sum = arr[0];\n\n    // Traverse through all the subarray\n    for i in 0..arr.len() {\n\n        // We use from i+1 to N inclusive\n        // Because j is ending range of the slice.\n        for j in i+1..arr.len()+1 {\n\n            // We find the sum of the subarray [i..j]\n            let mut sum = 0;\n            for k in i..j {\n                sum+=arr[k];\n            }\n\n            // Now compare the sum of this subarray with the max_sum\n            if max_sum < sum {\n                max_sum = sum;\n            }\n        }\n    }\n\n    return max_sum;\n}\n")),"\n",a.createElement(n.p,null,"With driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'fn max_subarray_sum(arr : Vec<i128>) -> i128{\n\n    // it is not initialized to 0 because array can be all negative elements.\n    let mut max_sum = arr[0];\n\n    // Traverse through all the subarray\n    for i in 0..arr.len() {\n\n        // We use from i+1 to N inclusive\n        // Because j is ending range of the slice.\n        for j in i+1..arr.len()+1 {\n\n            // We find the sum of the subarray [i..j]\n            let mut sum = 0;\n            for k in i..j {\n                sum+=arr[k];\n            }\n\n            // Now compare the sum of this subarray with the max_sum\n            if max_sum < sum {\n                max_sum = sum;\n            }\n        }\n    }\n\n    return max_sum;\n}\n\n// Driver Code\n\nfn main() {\n    let arr:Vec<i128> = vec![4, -5, 3, -2, 1, 5, -6, 3];\n    println!("{}", max_subarray_sum(arr));\n}\n\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"7"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( n",a.createElement("sup",null,"3")," )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",a.createElement(n.h2,{id:"efficient-kadanes-algorithm",style:{position:"relative"}},a.createElement(n.a,{href:"#efficient-kadanes-algorithm","aria-label":"efficient kadanes algorithm permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Efficient Kadane’s Algorithm"),"\n",a.createElement(n.p,null,"Using Kadane’s Algorithm, we can find Maximum Subarray Sum in ",a.createElement(n.strong,null,"Linear time complexity")," and constant space complexity."),"\n",a.createElement(n.h3,{id:"observation",style:{position:"relative"}},a.createElement(n.a,{href:"#observation","aria-label":"observation permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Observation"),"\n",a.createElement(n.p,null,"In Kadane’s Algorithm, we use a simple ",a.createElement(n.strong,null,"Observation"),", that if the sum of the elements upto a given element is negative, we can discard this sum.\nFor example, in array,"),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"[4, ",a.createElement(n.strong,null,"-5"),", 3, -2, 1, 5, -6, 3]"),"\n"),"\n",a.createElement(n.p,null,"We can see that sum of subarray [4, -5] is negative. So, we can easily discard this, because it will only decrease the sum of the elements. We can not include 4 without including -5. So, it is better to drop this subarray."),"\n",a.createElement(n.p,null,"But in the array"),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"[4, ",a.createElement(n.strong,null,"-3"),", 3, -2, 1, 5, -6, 3]"),"\n"),"\n",a.createElement(n.p,null,"We can include the subarray [4, -3] because its sum is positive."),"\n",a.createElement(n.h3,{id:"algorithm",style:{position:"relative"}},a.createElement(n.a,{href:"#algorithm","aria-label":"algorithm permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Initialise max_sum to any element of arr[] and current_sum to 0."),"\n",a.createElement(n.li,null,"Add the first element to the current_sum."),"\n",a.createElement(n.li,null,"If current_sum  is greater than the max_sum, set max_sum to current sum."),"\n",a.createElement(n.li,null,"If current sum is less than 0, set current_sum = 0."),"\n",a.createElement(n.li,null,"Repeat step 2 to 5 for each element of the arr[] and return the max_sum."),"\n"),"\n",a.createElement(n.p,null,"Function using this approach is"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn max_subarray_sum(arr : Vec<i128>) -> i128{\n\n    // max sum is not initialized to 0 because array can be all negative elements.\n    let mut max_sum = arr[0];\n    let mut current_sum = 0;\n\n\n    for i in 0..arr.len() {\n        // We add element to the current sum first\n        // because we have to consider single element also\n        current_sum+=arr[i];\n\n        // If current sum is greater than max sum, it becomes max.\n        if current_sum>max_sum {\n            max_sum = current_sum;\n        }\n\n        // Discard the current sum if it is less than 0\n        if current_sum < 0 {\n            current_sum = 0;\n        }\n    }\n\n    return max_sum;\n}\n")),"\n",a.createElement(n.p,null,"Use the same driver code."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"7"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( n )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",a.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},a.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",a.createElement(n.p,null,"Kadane's Algorithm is used to find the Maximum Subarray Sum in an array that may have positive as well as negative integers."),"\n",a.createElement(n.p,null,"In this article, we saw the Kadane's Algorithm and also wrote the function to find the Maximum Subarray Sum in Rust Language."),"\n",a.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn max_subarray_sum(arr : Vec<i128>) -> i128{\n    let mut mx = arr[0];\n    let mut curr = 0;\n    for i in 0..arr.len() {\n        curr+=arr[i];\n        if curr>mx { mx = curr; }\n        if curr < 0 { curr = 0; }\n    }\n    return mx;\n}\n")),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Thank You")),"\n","\n",a.createElement(i.H,{title:"Maximum Subarray Sum using Kadane’s Algorithm - Rust Programming",description:"Kadane's Algorithm is used to find the Maximum Subarray Sum in an array. In this article, we will see the Kadane's Algorithm and also write the function to find the Maximum Subarray Sum in the Rust Language"}))}var m=function(e){void 0===e&&(e={});var n=Object.assign({},(0,r.ah)(),e.components).wrapper;return n?a.createElement(n,e,a.createElement(s,e)):s(e)};function u(e){return e.children}function c(e){return a.createElement(u,e,a.createElement(m,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-1-array-algorithms-kadane-algorithms-mdx-8c3c6f87c14ba3b36b1e.js.map