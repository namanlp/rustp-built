"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[422],{85355:function(e,t,n){n.r(t),n.d(t,{default:function(){return u}});var r=n(27378),a=n(20951),l=n.p+"static/factors-of-number-192e80ccc1a249afb1886c688099fb3b.webp",o=n(88957);function c(e){var t=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",pre:"pre",code:"code",blockquote:"blockquote"},(0,a.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.h1,{id:"factors-of-a-natural-number",style:{position:"relative"}},r.createElement(t.a,{href:"#factors-of-a-natural-number","aria-label":"factors of a natural number permalink",className:"anchor before"},r.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Factors of a Natural Number"),"\n",r.createElement(t.p,null,"And a program in Rust to list all the factors of a natural number"),"\n",r.createElement(t.h2,{id:"what-are-factors-of-a-number",style:{position:"relative"}},r.createElement(t.a,{href:"#what-are-factors-of-a-number","aria-label":"what are factors of a number permalink",className:"anchor before"},r.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"What are Factors of a number"),"\n",r.createElement(t.p,null,"Factors or divisors of a natural number, say n, is a natural number, say m, that ",r.createElement(t.strong,null,"perfectly divides")," the number n. That is, ",r.createElement(t.strong,null,"n % m = 0"),". It can also be written that ",r.createElement(t.strong,null,"n = km"),", where k is also a natural number."),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"For Example :")," 1, 2, and 4 are factors of 4, but 3 is not a factor of 4"),"\n","\n",r.createElement("div",{style:{textAlign:"center"}},r.createElement("img",{src:l,width:"100%",alt:"Factors of 100"})),"\n",r.createElement(t.h2,{id:"naive-approach",style:{position:"relative"}},r.createElement(t.a,{href:"#naive-approach","aria-label":"naive approach permalink",className:"anchor before"},r.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Naive Approach"),"\n",r.createElement(t.p,null,"Naive or brute force approach is to traverse all the numbers from 1 to n, and add the number to vector if it divides the given number. Function for this approach in Rust is :"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-rust"},"fn list_factors(number:i128) -> Vec<i128>{\n    // Initialize factors Vector\n    let mut factors : Vec<i128> = Vec::new();\n\n    // Check all the numbers from 1 to n, both inclusive\n    for i in 1..(number+1) {\n        if number % i == 0 {\n            // Push the number to factors, if it divides number\n            factors.push(i);\n        }\n    }\n\n    // Return the factors Vector as answer\n    return factors;\n}\n")),"\n",r.createElement(t.p,null,"Program with driver code"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-rust"},'use std::io;\n\nfn list_factors(number:i128) -> Vec<i128>{\n    // Initialize factors Vector\n    let mut factors : Vec<i128> = Vec::new();\n\n    // Check all the numbers from 1 to n, both inclusive\n    for i in 1..(number+1) {\n        if number % i == 0 {\n            // Push the number to factors, if it divides number\n            factors.push(i);\n        }\n    }\n\n    // Return the factors Vector as answer\n    return factors;\n}\n\n// Driver Code\n\nfn main() {\n    // Read and parse number to i128\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let number : i128 = input.trim().parse().unwrap();\n\n    println!("{:?}", list_factors(number));\n}\n')),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Input")),"\n",r.createElement(t.blockquote,null,"\n",r.createElement(t.p,null,"100"),"\n"),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Output")),"\n",r.createElement(t.blockquote,null,"\n",r.createElement(t.p,null,"[1, 2, 4, 5, 10, 20, 25, 50, 100]"),"\n"),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Time Complexity : O(n)")," ",r.createElement("br"),"\n",r.createElement(t.strong,null,"Space Complexity : O( sqrt(n) )")),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Note :")," We can print the number instead of storing into the array or vector, to reduce ",r.createElement(t.strong,null,"Space Complexity to O(1)")," but it is rarely useful. Vector of factors is far more useful in real applications, so I will demonstrate Vector, instead of printing directly."),"\n",r.createElement(t.h2,{id:"efficient-approach",style:{position:"relative"}},r.createElement(t.a,{href:"#efficient-approach","aria-label":"efficient approach permalink",className:"anchor before"},r.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Efficient Approach"),"\n",r.createElement(t.p,null,"If you look the condition for factor carefully, that is"),"\n",r.createElement("center",null," ",r.createElement("b",null," n = k.m ")," "),"\n",r.createElement(t.p,null,"So, both k and m are factors of n, and not only m. So, ",r.createElement(t.strong,null,"all the factors of number are in pair")),"\n",r.createElement(t.p,null,"For example, factors of 100 are ( 1, 100 ), ( 2, 50 ), ( 4, 25 ), ( 5, 20 ) and ( 10, 10 ). Clearly,",r.createElement(t.strong,null,"If m is a factor of n, n/m is also a factor of n")),"\n",r.createElement(t.p,null,"Using this property, we only have to check for numbers till square root of n, because it can't be possible to get n, as a product of 2 numbers greater than square root of n."),"\n",r.createElement(t.p,null,"Function for this approach :"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-rust"},"fn list_factors(number:i128) -> Vec<i128>{\n    // Initialize factors Vector\n    let mut factors : Vec<i128> = Vec::new();\n\n    let mut i : i128 = 1;\n\n    // Check till i is less than or equal to square root n\n    while i*i <= number{\n        if number % i == 0 {\n            factors.push(i);\n\n            // to prevent duplication, if number is perfect square\n            if i*i != number {\n                factors.push(number / i);\n            }\n        }\n        i+=1;\n    }\n\n    // It is generally useful to sort the vector\n    // And it will not affect our time complexity,\n    // Because logarithmic time is much less than square root time complexity\n\n    factors.sort();\n\n    // Return the factors Vector as answer\n    return factors;\n}\n")),"\n",r.createElement(t.p,null,"Use the same driver code."),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Input")),"\n",r.createElement(t.blockquote,null,"\n",r.createElement(t.p,null,"100"),"\n"),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Output")),"\n",r.createElement(t.blockquote,null,"\n",r.createElement(t.p,null,"[1, 2, 4, 5, 10, 20, 25, 50, 100]"),"\n"),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Time Complexity : O( sqrt(n) )")," ",r.createElement("br"),"\n",r.createElement(t.strong,null,"Space Complexity : O( sqrt(n) )")),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Note :")," Repeating, We can print the number instead of storing into the array or vector, to reduce ",r.createElement(t.strong,null,"Space Complexity to O(1)")," but it is rarely useful. Vector of factors is far more useful in real applications, so I will demonstrate Vector, instead of printing directly."),"\n",r.createElement(t.h2,{id:"conclusion",style:{position:"relative"}},r.createElement(t.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},r.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",r.createElement(t.p,null,"Factors or divisors of a natural number are the numbers that perfectly divides it. In this article we made a program to list all the factors of a natural number in Rust, and also optimized it to square root time complexity. Here is the optimized function for easy access"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-rust"},"fn list_factors(number:i128) -> Vec<i128>{\n    let mut factors : Vec<i128> = Vec::new();\n    let mut i : i128 = 1;\n    while i*i <= number{\n        if number % i == 0 {\n            factors.push(i);\n            if i*i != number { factors.push(number / i); }\n        }\n        i+=1;\n    }\n    factors.sort();\n    return factors;\n}\n")),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Thank You")),"\n","\n",r.createElement(o.H,{title:"List Factors of a number",description:"Factors or divisors of a natural number are the numbers that perfectly divides it. Here, we will make a function to list all the factors of a natural number in Rust, and also optimize it to square root time complexity."}))}var i=function(e){void 0===e&&(e={});var t=Object.assign({},(0,a.ah)(),e.components).wrapper;return t?r.createElement(t,e,r.createElement(c,e)):c(e)};function s(e){return e.children}function u(e){return r.createElement(s,e,r.createElement(i,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-2-number-theory-2-2-factors-of-number-factors-of-natural-number-mdx-191a3a330968c6360ad5.js.map