{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/number-theory/gcd-or-hcf/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"GCD or HCF","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"GCD or HCF\",\n  \"section\": \"2.2 Factors of a Number\",\n  \"order\": 3,\n  \"slug\": \"/number-theory/gcd-or-hcf/\",\n  \"description\": \"Greatest Common Divisor or Highest Common Factor of two natural numbers is the largest natural number that divides both numbers. We will make function to find GCD or HCF of teo numbers and optimize it to logarithmic time complexity using Euclidean algorithm.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"gcd-or-hcf-of-two-numbers\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#gcd-or-hcf-of-two-numbers\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"GCD or HCF of two numbers\"), mdx(\"p\", null, \"and program in Rust to calculate it using Euclidean algorithm.\"), mdx(\"h2\", {\n    \"id\": \"what-is-gcd-or-hcf\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-is-gcd-or-hcf\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What is GCD or HCF\"), mdx(\"p\", null, \"Greatest Common Divisor ( GCD ) or Highest Common Factor ( HCF ) of two natural numbers is the largest natural number that divides both numbers.\"), mdx(\"p\", null, \"We can also say it is the largest natural number that is factor of both numbers.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"For Example :\"), \" GCD of 100 and 75 is 25\"), mdx(\"div\", {\n    style: {\n      textAlign: 'center'\n    }\n  }, mdx(\"img\", {\n    src: gcdHcf,\n    width: \"100%\",\n    alt: \"GCD of 150 and 210 is 30\"\n  })), mdx(\"h2\", {\n    \"id\": \"naive-approach\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#naive-approach\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Naive Approach\"), mdx(\"p\", null, \"Let us suppose we have to find gcd or hcf of 2 numbers, a and b.\"), mdx(\"p\", null, \"Naive or brute force approach is to traverse all the numbers from 1 to min(a, b), and check if the number divides both numbers. Function using this approach is\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn gcd(a:i128, b:i128) -> i128{\\n    // Initialize ans, or answer and limit\\n    let mut ans:i128 = 1;\\n    let limit = min(a,b);\\n\\n    // Loop from 2 to limit, both inclusive\\n    for i in 2..(limit+1) {\\n        // Check if both a and b are divisible\\n        if a%i == 0 && b%i == 0 {\\n            ans = i;\\n        }\\n    }\\n    return ans;\\n}\\n\")), mdx(\"p\", null, \"Program With driver code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::cmp::min;\\nuse std::io::stdin;\\n\\n// Read Input\\n\\nfn take_vector() -> Vec<i128> {\\n    let mut input = String::new();\\n    stdin().read_line(&mut input).unwrap();\\n    let arr: Vec<i128> = input.trim().\\n        split_whitespace().map(|x| x.parse().unwrap()).collect();\\n    return arr;\\n}\\n\\n// Magic Starts here\\n\\nfn gcd(a:i128, b:i128) -> i128{\\n    // Initialize ans, or answer and limit\\n    let mut ans:i128 = 1;\\n    let limit = min(a,b);\\n\\n    // Loop from 2 to limit, both inclusive\\n    for i in 2..(limit+1) {\\n        // Check if both a and b are divisible\\n        if a%i == 0 && b%i == 0 {\\n            ans = i;\\n        }\\n    }\\n    return ans;\\n}\\n\\n// Driver Code\\n\\npub fn main() {\\n    let numbers = take_vector();\\n    println!(\\\"{}\\\", gcd(numbers[0], numbers[1]));\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Input\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"210 150\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"30\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( min (a, b) )\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O( 1 )\")), mdx(\"h2\", {\n    \"id\": \"efficient-euclidean-algorithm\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#efficient-euclidean-algorithm\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Efficient Euclidean algorithm\"), mdx(\"p\", null, \"We can find the gcd of 2 numbers using Euclidean algorithm in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"logarithmic time complexity\")), mdx(\"p\", null, \"Refer \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Euclidean_algorithm\"\n  }, \"Wikipedia\")), mdx(\"p\", null, \"In simple words, let us suppose that we have to find gcd of 2 distinct numbers, a and b, such that a > b.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a%b == 0, then obviously b is the gcd.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a%b != 0, then gcd must divide both b and a%b ( from Euclidean algorithm or even general observation ). So, we can now find gcd of b and a%b, which will be the answer.\")), mdx(\"p\", null, \"Also, clearly, b > a%b.\"), mdx(\"p\", null, \"Function using this approach is\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn gcd(mut a:i128, mut b:i128) -> i128{\\n    // If equal, return any of them\\n    if a==b {\\n        return a;\\n    }\\n\\n    // Swap a with b, if b is greater than a\\n    if b > a {\\n        let temp = a;\\n        a = b;\\n        b = temp;\\n    }\\n\\n    while b>0 {\\n        // This is the trickiest part\\n        // We swap a with b, and b with a%b, till b becomes 0\\n        let temp = a;\\n        a = b;\\n        b = temp%b;\\n    }\\n\\n    // Now, a%b = 0, hence return it\\n    return a;\\n}\\n\")), mdx(\"p\", null, \"Use the same driver code.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Input\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"210 150\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"30\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( log(min (a, b)) )\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O( 1 )\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"Greatest Common Divisor ( GCD ) or Highest Common Factor ( HCF ) of two natural numbers is the largest natural number that divides both numbers. In this article, we made a program to compute GCD or HCF in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Logarithmic Time Complexity\"), \" using Euclidean algorithm.\"), mdx(\"p\", null, \"Here is the optimized function for easy access\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn gcd(mut a:i128, mut b:i128) -> i128{\\n    if a==b { return a; }\\n    if b > a {\\n        let temp = a;\\n        a = b;\\n        b = temp;\\n    }\\n    while b>0 {\\n        let temp = a;\\n        a = b;\\n        b = temp%b;\\n    }\\n    return a;\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"Greatest Common Divisor or Highest Common Factor of two natural numbers is the largest natural number that divides both numbers. We will make function to find GCD or HCF of teo numbers and optimize it to logarithmic time complexity using Euclidean algorithm.\",\n    openGraph: {\n      description: 'Greatest Common Divisor or Highest Common Factor of two natural numbers is the largest natural number that divides both numbers. We will make function to find GCD or HCF of teo numbers and optimize it to logarithmic time complexity using Euclidean algorithm.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#gcd-or-hcf-of-two-numbers","title":"GCD or HCF of two numbers","items":[{"url":"#what-is-gcd-or-hcf","title":"What is GCD or HCF"},{"url":"#naive-approach","title":"Naive Approach"},{"url":"#efficient-euclidean-algorithm","title":"Efficient Euclidean algorithm"},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"42e49b12-ddce-5366-9083-9a19e5f66b96"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","4275725850"]}