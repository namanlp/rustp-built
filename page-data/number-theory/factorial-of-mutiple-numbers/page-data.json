{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/number-theory/factorial-of-mutiple-numbers/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Factorial Of Multiple Numbers","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Factorial Of Multiple Numbers\",\n  \"section\": \"2.3 Factorials\",\n  \"order\": 3,\n  \"slug\": \"/number-theory/factorial-of-mutiple-numbers/\",\n  \"description\": \"Calculating factorial of multiple numbers may take time O( m × n ) . But, we can calculate it in linear space and time complexity using Dynamic Programming and generating Factorial Array.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"factorial-of-multiple-numbers\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#factorial-of-multiple-numbers\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Factorial Of Multiple Numbers\"), mdx(\"p\", null, \"Using Dynamic Programming and Factorial Array\"), mdx(\"h2\", {\n    \"id\": \"program-without--dynamic-programming\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#program-without--dynamic-programming\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Program without  Dynamic Programming\"), mdx(\"p\", null, \"In the previous article, we discussed how to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/factorial-of-number/\"\n  }, \"find factorial of a number\"), \" and how to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/factorial-of-large-numbers/\"\n  }, \"find factorial of very large numbers using Modular Arithmetic.\")), mdx(\"p\", null, \"As we have already seen in these article, the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity for calculating the factorial of each number is O( n )\"), \"\\nSo, if we find the factorial of m numbers, clearly the time complexity will be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( m \\xD7 n )\"), \" , where n is the largest number among m numbers.\"), mdx(\"p\", null, \"Now, let's see a code to demonstrate this. We will use the Iterative function used in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/factorial-of-large-numbers/\"\n  }, \"find factorial of very large numbers using Modular Arithmetic.\")), mdx(\"p\", null, \"Program\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io::stdin;\\n\\nfn factorial(number : i128, divisor: i128) -> i128 {\\n    let mut factorial: i128 = 1;\\n    for i in 1..(number + 1) {\\n        factorial *= i;\\n        factorial %= divisor;\\n    }\\n    return factorial;\\n}\\n\\npub fn main() {\\n    println!(\\\"Enter array : \\\");\\n\\n    // Read Array of Integers\\n    let mut input = String::new();\\n    stdin().read_line(&mut input).unwrap();\\n    let arr: Vec<i128> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n\\n    // For all number in array, find and print factorial, modulo 1000000007\\n    // You can replace 1000000007 with any number you like\\n    // Also, I am using borrowing, so that we can reuse the array again later\\n\\n    for number in &arr {\\n        let factorial = factorial(*number, 1000000007);\\n        println!(\\\"Factorial of {} is : {}\\\", number,  factorial);\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Enter array : \", mdx(\"br\", null), \"\\n12 13 14 15 16 \", mdx(\"br\", null), \"\\nFactorial of 12 is : 479001600 \", mdx(\"br\", null), \"\\nFactorial of 13 is : 227020758 \", mdx(\"br\", null), \"\\nFactorial of 14 is : 178290591 \", mdx(\"br\", null), \"\\nFactorial of 15 is : 674358851 \", mdx(\"br\", null), \"\\nFactorial of 16 is : 789741546\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( m\\xD7n )\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O(1)\")), mdx(\"h2\", {\n    \"id\": \"overlapping-sub-problems\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#overlapping-sub-problems\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Overlapping Sub-problems\"), mdx(\"p\", null, \"In the above example, we are calculating the factorial of array \", \"[12, 13, 14, 15, 16]\", \".\"), mdx(\"p\", null, \"For this, we are first calculating 12!, then again 12! and multiply it with 13, to get 13!, then again calculate 13! and multiply with 14 to get 14! and so on. It is depicted by picture below\"), mdx(\"div\", {\n    style: {\n      textAlign: 'center'\n    }\n  }, mdx(\"img\", {\n    src: MultipleNumberOverlapping,\n    width: \"100%\",\n    alt: \"Overlapping Sub-problems\"\n  })), mdx(\"p\", null, \"So, instead of calculating factorial of 12 5 times, we calculate it once and store it,  and again access it, when needed\"), mdx(\"h2\", {\n    \"id\": \"tabulation-method--dynamic-programming-\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#tabulation-method--dynamic-programming-\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tabulation Method ( Dynamic Programming )\"), mdx(\"p\", null, \"In Tabulation method, we simply create an array, in which index represents the factorial of number.\\nSo,\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"factorial_array\", \"[0]\", \" = 0! = 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"factorial_array\", \"[1]\", \" = 1! = 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"factorial_array\", \"[2]\", \" = 2! = 2\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"factorial_array\", \"[3]\", \" = 3! = 6\")), mdx(\"p\", null, \"and so on.\"), mdx(\"p\", null, \"We can easily use it in the code, any way we like.\"), mdx(\"p\", null, \"If we already have factorial array, then finding factorial of any number is done in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity = O( 1 )\"), \", like in above permutation, it takes constant time complexity !\"), mdx(\"p\", null, \"Following function generates factorial array, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" which contains factorial of all numbers upto given maximum number\"), \". It also receives a divisor, to store modulo of number, instead of given number itself\"), mdx(\"h3\", {\n    \"id\": \"function-to-generate-factorial-array\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#function-to-generate-factorial-array\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Function to generate factorial array\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn generate_factorial_array(max_number : i128, divisor : i128) -> Vec<i128>{\\n    // This function generates and returns an array,\\n    // with index representing factorial of the number\\n\\n    // Convert i128 to usize, so that we can access array slices in rust\\n    let max_number : usize = max_number as usize;\\n\\n    // Initially set every element to 0\\n    let mut factorial_array : Vec<i128> = vec![0; max_number+1];\\n    factorial_array[0] = 1;\\n    factorial_array[1] = 1;\\n\\n    // Set next factorial to i * previous factorial % divisor\\n    for i in 2..(max_number + 1) {\\n        factorial_array[i] = (factorial_array[i-1] * (i as i128)) % divisor;\\n    }\\n\\n    return factorial_array\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"with-driver-code-or-the-implementation-of-above-function\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#with-driver-code-or-the-implementation-of-above-function\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"With driver code, or the implementation of above function\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io::stdin;\\n\\nfn generate_factorial_array(max_number : i128, divisor : i128) -> Vec<i128>{\\n    // This function generates and returns an array, with index representing factorial of the number\\n\\n    // Convert i128 to usize, so that we can access array slices in rust\\n    let max_number : usize = max_number as usize;\\n\\n    // Initially set every element to 0\\n    let mut factorial_array : Vec<i128> = vec![0; max_number+1];\\n    factorial_array[0] = 1;\\n    factorial_array[1] = 1;\\n\\n    // Set next factorial to i * previous factorial % divisor\\n    for i in 2..(max_number + 1) {\\n        factorial_array[i] = (factorial_array[i-1] * (i as i128)) % divisor;\\n    }\\n\\n    return factorial_array\\n}\\n\\npub fn main() {\\n    // Read Array of Integers\\n    println!(\\\"Enter array : \\\");\\n    let mut input = String::new();\\n    stdin().read_line(&mut input).unwrap();\\n    let arr: Vec<i128> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n\\n    // Read Divisor\\n    println!(\\\"Enter divisor : \\\");\\n    input.clear();\\n    stdin().read_line(&mut input).unwrap();\\n    let divisor : i128 = input.trim().parse().unwrap();\\n\\n    // Find Maximum number in the array\\n    let mut max_number: i128 = arr[0];\\n    for i in &arr {\\n        if *i > max_number {\\n            max_number = *i;\\n        }\\n    }\\n\\n    // Now, generate the factorial array for the maximum number and divisor\\n    let factorial_array = generate_factorial_array(max_number, divisor);\\n\\n    // Now, print the factorial of each element in array, using above generated factorial array.\\n    for i in &arr {\\n        print!(\\\" {} \\\", factorial_array[*i as usize])\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Enter array : \", mdx(\"br\", null), \"\\n12 13 14 15 16 \", mdx(\"br\", null), \"\\nFactorial of 12 is : 479001600 \", mdx(\"br\", null), \"\\nFactorial of 13 is : 227020758 \", mdx(\"br\", null), \"\\nFactorial of 14 is : 178290591 \", mdx(\"br\", null), \"\\nFactorial of 15 is : 674358851 \", mdx(\"br\", null), \"\\nFactorial of 16 is : 789741546\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( n + m )\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O( n )\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note :\"), \" Complexity O( m+n ) signifies that time complexity is maximum O( m ) and O ( n ). Hence, it is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Linear Time and Space Complexity\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"If we find the factorial of multiple numbers one by one, it may take time O( m \\xD7 n ) or quadratic time complexity. But, we can calculate it in linear space and time complexity using Dynamic Programming and generating Factorial Array.\"), mdx(\"p\", null, \"Reading these articles, you now know much about factorials and how to efficiently code factorial programs in rust.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"Calculating factorial of multiple numbers may take time O( m \\xD7 n ) . But, we can calculate it in linear space and time complexity using Dynamic Programming and generating Factorial Array.\",\n    openGraph: {\n      description: 'Calculating factorial of multiple numbers may take time O( m × n ) . But, we can calculate it in linear space and time complexity using Dynamic Programming and generating Factorial Array.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#factorial-of-multiple-numbers","title":"Factorial Of Multiple Numbers","items":[{"url":"#program-without--dynamic-programming","title":"Program without  Dynamic Programming"},{"url":"#overlapping-sub-problems","title":"Overlapping Sub-problems"},{"url":"#tabulation-method--dynamic-programming-","title":"Tabulation Method ( Dynamic Programming )","items":[{"url":"#function-to-generate-factorial-array","title":"Function to generate factorial array"},{"url":"#with-driver-code-or-the-implementation-of-above-function","title":"With driver code, or the implementation of above function"}]},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"b692cbed-5cfb-521a-9445-02184e58f03f"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","4275725850"]}