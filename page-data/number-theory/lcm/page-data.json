{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/number-theory/lcm/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"LCM using Euclidean algorithm","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"LCM using Euclidean algorithm\",\n  \"section\": \"2.2 Factors of a Number\",\n  \"order\": 4,\n  \"slug\": \"/number-theory/lcm/\",\n  \"description\": \"Least Common Multiple of two natural numbers is the smallest natural number that is divisible by both the numbers. We will make function to find LCM of two numbers and optimize it to logarithmic time complexity using Euclidean algorithm in Rust.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"least-common-multiple\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#least-common-multiple\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Least Common Multiple\"), mdx(\"p\", null, \"and program in Rust to calculate it using Euclidean algorithm.\"), mdx(\"h2\", {\n    \"id\": \"what-is-least-common-multiple--lcm-\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-is-least-common-multiple--lcm-\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What is Least Common Multiple ( LCM )\"), mdx(\"p\", null, \"Least Common Multiple of two natural numbers is the smallest natural number that is divisible by both the numbers.\"), mdx(\"p\", null, \"Lowest Common denominator is used for rational numbers, and it is LCM of denominators of both numbers.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"For Example :\"), \" LCM of 100 and 75 is 300\"), mdx(\"div\", {\n    style: {\n      textAlign: 'center'\n    }\n  }, mdx(\"img\", {\n    src: lcm,\n    width: \"100%\",\n    alt: \"LCM of 150 and 210 is 1050\"\n  })), mdx(\"h2\", {\n    \"id\": \"naive-approach\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#naive-approach\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Naive Approach\"), mdx(\"p\", null, \"Let us suppose we have to find Least Common Multiple ( LCM ) of 2 numbers, a and b.\"), mdx(\"p\", null, \"The naive or brute force approach would be to traverse all the numbers from max(a, b) to a \\xD7 b and find if it is divisible by both a and b. If yes, print the number and return.\"), mdx(\"p\", null, \"We will not write its code, because it is very clumsy.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( a \\xD7 b )\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O( 1 )\")), mdx(\"h2\", {\n    \"id\": \"efficient-euclidean-algorithm\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#efficient-euclidean-algorithm\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Efficient Euclidean algorithm\"), mdx(\"p\", null, \"We know that, product of 2 numbers is equal to product of their GCD and LCM. Mathematically,\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \" a \\xD7 b = GCD(a, b) \\xD7 LCM(a, b)\"), \" \"), mdx(\"p\", null, \"We already saw \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/gcd-or-hcf/\"\n  }, \"How To find HCF of 2 numbers using Euclidean Algorithm Here\"), \". We will use this function to find LCM of 2 numbers.\"), mdx(\"p\", null, \"So,\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \" LCM (a, b) = (a \\xD7 b) / HCF(a, b)\"), \" \"), mdx(\"p\", null, \"Function using this approach is\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// Find GCD\\nfn gcd(mut a:i128, mut b:i128) -> i128{\\n    if a==b { return a; }\\n    if b > a {\\n        let temp = a;\\n        a = b;\\n        b = temp;\\n    }\\n    while b>0 {\\n        let temp = a;\\n        a = b;\\n        b = temp%b;\\n    }\\n    return a;\\n}\\n\\nfn lcm(a:i128, b:i128) -> i128{\\n    // LCM = a*b / gcd\\n    return a*(b/gcd(a,b));\\n}\\n\")), mdx(\"p\", null, \"With driver code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io::stdin;\\n\\n// Read Input\\n\\nfn take_vector() -> Vec<i128> {\\n    let mut input = String::new();\\n    stdin().read_line(&mut input).unwrap();\\n    let arr: Vec<i128> = input.trim()\\n        .split_whitespace().map(|x| x.parse().unwrap()).collect();\\n    return arr;\\n}\\n\\n// Magic Starts here\\n\\n// Find GCD\\nfn gcd(mut a:i128, mut b:i128) -> i128{\\n    if a==b { return a; }\\n    if b > a {\\n        let temp = a;\\n        a = b;\\n        b = temp;\\n    }\\n    while b>0 {\\n        let temp = a;\\n        a = b;\\n        b = temp%b;\\n    }\\n    return a;\\n}\\n\\nfn lcm(a:i128, b:i128) -> i128{\\n    // LCM = a*b / gcd\\n    return a * (b/gcd(a,b));\\n}\\n\\n// Driver Code\\n\\npub fn main() {\\n    let numbers = take_vector();\\n    println!(\\\"{}\\\", lcm(numbers[0], numbers[1]));\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Input\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"210 150\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"1050\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( log(min (a, b)) )\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O( 1 )\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"Least Common Multiple of two natural numbers is the smallest natural number that is divisible by both the numbers.\\nIn this article, we made a program to compute Least Common Multiple (LCM) of two numbers in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Logarithmic Time Complexity\"), \" using Euclidean algorithm in Rust.\"), mdx(\"p\", null, \"Here is optimized function for easy access.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn gcd(mut a:i128, mut b:i128) -> i128{\\n    if a==b { return a; }\\n    if b > a {\\n        let temp = a;\\n        a = b;\\n        b = temp;\\n    }\\n    while b>0 {\\n        let temp = a;\\n        a = b;\\n        b = temp%b;\\n    }\\n    return a;\\n}\\n\\nfn lcm(a:i128, b:i128) -> i128{\\n    return a*(b/gcd(a,b));\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"Least Common Multiple of two natural numbers is the smallest natural number that is divisible by both the numbers. We will make function to find LCM of two numbers and optimize it to logarithmic time complexity using Euclidean algorithm in Rust.\",\n    openGraph: {\n      description: 'Least Common Multiple of two natural numbers is the smallest natural number that is divisible by both the numbers. We will make function to find LCM of two numbers and optimize it to logarithmic time complexity using Euclidean algorithm in Rust.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#least-common-multiple","title":"Least Common Multiple","items":[{"url":"#what-is-least-common-multiple--lcm-","title":"What is Least Common Multiple ( LCM )"},{"url":"#naive-approach","title":"Naive Approach"},{"url":"#efficient-euclidean-algorithm","title":"Efficient Euclidean algorithm"},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"456c104f-dd38-530e-b73b-e53717ab1236"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","3597609067"]}