{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/number-theory/factorial-of-large-numbers/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Factorial Of Very Large Numbers","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Factorial Of Very Large Numbers\",\n  \"section\": \"1. Number Theory\",\n  \"order\": 81,\n  \"slug\": \"/number-theory/factorial-of-large-numbers/\",\n  \"description\": \"Factorial is an important value of a number. But calculating factorial of very large can result in overflow. In this article, we calculate factorial of very large numbers using Modular Arithmetic.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"factorial-of-very-large-numbers\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#factorial-of-very-large-numbers\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Factorial Of Very Large Numbers\"), mdx(\"p\", null, \"Using Remainder and Modular Arithmetic\"), mdx(\"h2\", {\n    \"id\": \"why-do-we-need-modulo\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#why-do-we-need-modulo\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Why do we need Modulo\"), mdx(\"p\", null, \"The program discussed in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/factorial-of-number/\"\n  }, \"Finding Factorial Of a Number\"), \" page finds the factorial of a given number. But factorial of number grows very fast with number. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Factorial of 100 is 9.33 \\xD7 10\\xB9\\u2075\\u2077\"), \"\\nSo, it becomes impossible to store such large number as number in many languages, like \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C, C++, Rust\"), \" etc. ( Though some languages like Python allow number of any length being stored ).\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Largest integer data type in rust is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"i128\"), \" which can store data from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-170141183460469231731687303715884105728\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"170141183460469231731687303715884105727\"), \" which is roughly of order \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"10\\xB3\\u2078\"), \" \", mdx(\"br\", null), \" \", mdx(\"br\", null)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If we try to store a number beyond this range, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"the number will overflow, and an error will be thrown!.\"), \" Like, if we try to find 100!\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"thread 'main' panicked at 'attempt to multiply with overflow', src/iterative.rs:10:9\\n\")), mdx(\"p\", null, \"Therefore, we must find an alternate to store and use the factorial of larger numbers.\"), mdx(\"h2\", {\n    \"id\": \"using-modulo-of-number-to-store\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#using-modulo-of-number-to-store\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Using Modulo of Number to store\"), mdx(\"p\", null, \"As we saw above, we can not store the complete number. But we can store it's modulo from a number.\"), mdx(\"p\", null, \"In most programming contest, a specific number is mentioned, generally \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\\u2079 + 7 or 1000000007\"), \" is used because It is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"safe prime number\"), \".\"), mdx(\"p\", null, \"But we will see a function that generates factorial of a number modulo any other number. Also, it is guaranteed that number will be less than the second number. That is, if we find factorial modulo 13, it is guaranteed that the answer will be less than 13.\\nHence, it will ensure that the number doesn't overflow.\"), mdx(\"h3\", {\n    \"id\": \"property-used\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#property-used\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Property Used\"), mdx(\"p\", null, \"We take the help of special property in Modular Mathematics, which is called Modular Multiplication Property\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \"(a x b) mod m = ((a mod m) x (b mod m)) mod m\"), \" \"), mdx(\"p\", null, \"Also, we know that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"n! = n \\xD7 (n-1)!\"), \". Therefore,\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"n! mod m = ((n mod m) x ((n-1)! mod m)) mod m\")), mdx(\"p\", null, \"Also, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n mod m = n\"), \" because if n is greater or equal to m, final result will be 0, because n! will already contain m, and hence, it is always divisible by m.\"), mdx(\"p\", null, \"If n is less than m, than n mod m = n always.\"), mdx(\"p\", null, \"Also, (n-1)! is already modulo m. So, no need to find modulo m again.So, finally, we use equation\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \"n! mod m = ( n x (n-1)! ) mod m\"), \" \"), mdx(\"h2\", {\n    \"id\": \"recursive-approach\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#recursive-approach\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Recursive Approach\"), mdx(\"p\", null, \"In the code seen in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/factorial-of-number/\"\n  }, \"Finding Factorial of a Number\"), \" page, we just \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"return number modulo divisor\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"\\nfn factorial_recursive(number : i128, divisor: i128) -> i128{\\n\\n    // Base Case\\n    if number<=1 {\\n        return 1;\\n    }\\n\\n    // Recursive Case\\n    return (number * factorial_recursive(number-1, divisor) ) % divisor;\\n}\\n\")), mdx(\"p\", null, \"Program with Driver Code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io::stdin;\\n\\nfn factorial_recursive(number : i128, divisor: i128) -> i128{\\n\\n    // Base Case\\n    if number<=1 {\\n        return 1;\\n    }\\n\\n    // Recursive Case\\n    return (number * factorial_recursive(number-1, divisor) ) % divisor;\\n}\\n\\n// Driver Code\\n\\npub fn main() {\\n\\n    // Read and parse number to i128\\n    let mut input = String::new();\\n    stdin().read_line(&mut input).unwrap();\\n    let number : i128 = input.trim().parse().unwrap();\\n\\n    input.clear();\\n\\n    stdin().read_line(&mut input).unwrap();\\n    let divisor : i128 = input.trim().parse().unwrap();\\n\\n    // Find and print factorial\\n    let factorial = factorial_recursive(number, divisor);\\n    println!(\\\"Factorial of {} is : {}\\\", number,  factorial);\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"12345 \", mdx(\"br\", null), \"\\n1000000007 \", mdx(\"br\", null), \"\\nFactorial of 12345 is : 579592771\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O(n)\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O(n)\")), mdx(\"p\", null, \"As you can see, we can easily find factorial of number as large as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"12345\"), \" modulo some other number easily.\"), mdx(\"h2\", {\n    \"id\": \"iterative-approach\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#iterative-approach\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Iterative Approach\"), mdx(\"p\", null, \"In this, we multiply all the number from 1 to the given number, and each time store the remainder.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn factorial(number : i128, divisor: i128) -> i128{\\n\\n    // initialize factorial to 1, explicitly type i128\\n    let mut factorial : i128 = 1;\\n\\n    // Multiply factorial by all numbers from 1 to the given number\\n    for i in 1..(number+1) {\\n        factorial*=i;\\n        // Find remainder\\n        factorial%=divisor;\\n    }\\n\\n    // Return factorial\\n    return factorial\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"12345 \", mdx(\"br\", null), \"\\n1000000007 \", mdx(\"br\", null), \"\\nFactorial of 12345 is : 579592771\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O(n)\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O(1)\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note :\"), \" Iterative approach is more efficient than recursive approach !\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"This article covered how to find factorial of very large numbers, using both Iterative and recursive methods in rust.\"), mdx(\"p\", null, \"In the next article, we will see how to find the factorial of multiple numbers.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"Factorial is an important value of a number. But calculating factorial of very large can result in overflow. In this article, we calculate factorial of very large numbers using Modular Arithmetic.\",\n    openGraph: {\n      description: 'Factorial is an important value of a number. But calculating factorial of very large can result in overflow. In this article, we calculate factorial of very large numbers using Modular Arithmetic.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#factorial-of-very-large-numbers","title":"Factorial Of Very Large Numbers","items":[{"url":"#why-do-we-need-modulo","title":"Why do we need Modulo"},{"url":"#using-modulo-of-number-to-store","title":"Using Modulo of Number to store","items":[{"url":"#property-used","title":"Property Used"}]},{"url":"#recursive-approach","title":"Recursive Approach"},{"url":"#iterative-approach","title":"Iterative Approach"},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"4c141f0f-0814-582f-88fd-0888e0f3209a"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","3442269102","4275725850"]}