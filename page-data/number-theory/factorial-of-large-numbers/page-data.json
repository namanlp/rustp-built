{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/number-theory/factorial-of-large-numbers/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Factorial Of Very Large Numbers","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Factorial Of Very Large Numbers\",\n  \"section\": \"Number Theory\",\n  \"order\": 81,\n  \"slug\": \"/number-theory/factorial-of-large-numbers/\",\n  \"description\": \"Factorial is an important value of a number. But calculating factorial of very large can result in overflow. This article deals with this problem using modular arithmetic or modulo.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"factorial-of-very-large-numbers\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#factorial-of-very-large-numbers\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Factorial Of Very Large Numbers\"), mdx(\"p\", null, \"Using Remainder and Modular Arithmetic\"), mdx(\"h2\", {\n    \"id\": \"why-do-we-need-modulo\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#why-do-we-need-modulo\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Why do we need Modulo\"), mdx(\"p\", null, \"The program discussed in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/factorial-of-number/\"\n  }, \"Finding Factorial Of a Number\"), \" page finds the factorial of a given number. But factorial of number grows very fast with number. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Factorial of 100 is 9.33 \\xD7 10\\xB9\\u2075\\u2077\"), \"\\nSo, it becomes impossible to store such large number as number in many languages, like \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C, C++, Rust\"), \" etc. ( Though some languages like Python allow number of any length being stored ).\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Largest integer data type in rust is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"i128\"), \" which can store data from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-170141183460469231731687303715884105728\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"170141183460469231731687303715884105727\"), \" which is roughly of order \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"10\\xB3\\u2078\"), \" \", mdx(\"br\", null), \" \", mdx(\"br\", null)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If we try to store a number beyond this range, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"the number will overflow, and an error will be thrown!\"))), mdx(\"p\", null, \"Therefore, we must find an alternate to store and use the factorial of larger numbers.\"), mdx(\"h2\", {\n    \"id\": \"using-modulo-of-number-to-store\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#using-modulo-of-number-to-store\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Using Modulo of Number to store\"), mdx(\"p\", null, \"As we saw above, we can not store the complete number. But we can store it's modulo from a number.\"), mdx(\"p\", null, \"In most programming contest, a specific number is mentioned, generally \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\\u2079 + 7 or 1000000007\"), \" is used because It is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"safe prime number\"), \".\"), mdx(\"p\", null, \"But we will see a function that generates factorial of a number modulo any other number. Also, it is guaranteed that number will be less than the second number. That is, if we find factorial modulo 13, it is guaranteed that the answer will be less than 13.\\nHence, it will ensure that the number doesn't overflow.\"), mdx(\"h2\", {\n    \"id\": \"recursive-approach\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#recursive-approach\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Recursive Approach\"), mdx(\"p\", null, \"In the code seen in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/factorial-of-number/\"\n  }, \"Finding Factorial of a Number\"), \" page, we just \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"return number modulo divisor\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"\\nfn factorial_recursive(number : i128, divisor: i128) -> i128{\\n\\n    // Base Case\\n    if number<=1 {\\n        return 1;\\n    }\\n\\n    // Recursive Case\\n    return ( (number%divisor) * factorial_recursive(number-1, divisor) ) % divisor;\\n}\\n\")), mdx(\"p\", null, \"Program with Driver Code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io::stdin;\\n\\nfn factorial_recursive(number : i128, divisor: i128) -> i128{\\n\\n    // Base Case\\n    if number<=1 {\\n        return 1;\\n    }\\n\\n    // Recursive Case\\n    return ( (number%divisor) * factorial_recursive(number-1, divisor) ) % divisor;\\n}\\n\\n// Driver Code\\n\\npub fn main() {\\n\\n    // Read and parse number to i128\\n    let mut input = String::new();\\n    stdin().read_line(&mut input).unwrap();\\n    let number : i128 = input.trim().parse().unwrap();\\n\\n    input.clear();\\n\\n    stdin().read_line(&mut input).unwrap();\\n    let divisor : i128 = input.trim().parse().unwrap();\\n\\n    // Find and print factorial\\n    let factorial = factorial_recursive(number, divisor);\\n    println!(\\\"Factorial of {} is : {}\\\", number,  factorial);\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#factorial-of-very-large-numbers","title":"Factorial Of Very Large Numbers","items":[{"url":"#why-do-we-need-modulo","title":"Why do we need Modulo"},{"url":"#using-modulo-of-number-to-store","title":"Using Modulo of Number to store"},{"url":"#recursive-approach","title":"Recursive Approach"}]}]}}},"pageContext":{"id":"4c141f0f-0814-582f-88fd-0888e0f3209a"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","3442269102","4275725850"]}