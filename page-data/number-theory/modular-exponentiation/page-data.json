{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/number-theory/modular-exponentiation/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Modular Exponentiation","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Modular Exponentiation\",\n  \"section\": \"2.1 Arithmetic Operations\",\n  \"order\": 2,\n  \"slug\": \"/number-theory/modular-exponentiation/\",\n  \"description\": \"Modular exponentiation is very frequently used concept in competitive programming. Here is the program for modular exponentiation in rust in logarithmic time complexity instead of linear using Divide and Conquer.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"modular-exponentiation-in-rust\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#modular-exponentiation-in-rust\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Modular Exponentiation in Rust\"), mdx(\"p\", null, \"And its Program in Rust\"), mdx(\"h2\", {\n    \"id\": \"what-is-modular-exponentiation\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-is-modular-exponentiation\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What is Modular Exponentiation\"), mdx(\"p\", null, \"Many times, we have to compute exponents of a given number for various purposes. But it is notable that overflow may occur for large values. Largest number that we can store with numerical data type in rust is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"2\\xB9\\xB2\\u2078\")), \", and is 2\", mdx(\"sup\", null, \"64\"), \" in C / C++.\"), mdx(\"p\", null, \"Now, suppose, in some question, we have to find \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"2\\xB9\\u2070\\u2070\\u2070\")), \" modulo 1000000007. If we try to first compute \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"2\\xB9\\u2070\\u2070\\u2070\")), \" and then find modulo, rust will throw overflow error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"thread 'main' panicked at 'attempt to multiply with overflow', src/iterative.rs:10:9\\n\")), mdx(\"h2\", {\n    \"id\": \"problem-statement\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#problem-statement\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Problem statement\"), mdx(\"p\", null, \"Given three numbers n, x and p, compute n\", mdx(\"sup\", null, \"x\"), \"  modulo p.\"), mdx(\"h2\", {\n    \"id\": \"naive-approach\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#naive-approach\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Naive Approach\"), mdx(\"p\", null, \"Simplest solution to this would be to take 1, and multiply it with n, x times, and find modulo p each time. From \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/number-theory/modular-multiplication/#2-multiplication-property\"\n  }, \"Modular Multiplication\"), \", we already know that\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \"(a x b) mod m = ((a mod m) x (b mod m)) mod m\"), \" \"), mdx(\"p\", null, \"But this will be done in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( x )\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Linear time complexity.\")), mdx(\"p\", null, \"Here's the code for this approach\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn modular_exponent(n:i128 , x:i128 , p:i128) -> i128{\\n    // Initialize ans = 1\\n    let mut ans = 1;\\n\\n    // Multiply ans with n, x times, ans modulo\\n    for _ in 0..x {\\n        ans *= n;\\n        ans%=p;\\n    }\\n\\n    // Return ans\\n    return ans;\\n}\\n\")), mdx(\"p\", null, \"With Driver Code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn modular_exponent(n:i128 , x:i128 , p:i128) -> i128{\\n    // Initialize ans = 1\\n    let mut ans = 1;\\n\\n    // Multiply ans with n, x times, ans modulo\\n    for _ in 0..x {\\n        ans *= n;\\n        ans%=p;\\n    }\\n\\n    // Return ans\\n    return ans;\\n}\\n\\n// Driver Code\\n\\nuse std::io;\\n\\nfn take_int() -> i128 {\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).unwrap();\\n    return input.trim().parse().unwrap();\\n}\\n\\nfn main() {\\n    let n = take_int();\\n    let x = take_int();\\n    let p = take_int();\\n\\n    println!(\\\"{}\\\", modular_exponent(n, x, p));\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Input\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"2 \", mdx(\"br\", null), \"\\n100000 \", mdx(\"br\", null), \"\\n1000000007 \", mdx(\"br\", null))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"607723520\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( x )\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O( 1 )\")), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"efficient-divide-and-conquer-solution\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#efficient-divide-and-conquer-solution\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Efficient Divide and Conquer solution\"), mdx(\"p\", null, \"We can find the modular exponentiation in logarithmic time complexity, using  Divide and Conqueror approach.\"), mdx(\"h3\", {\n    \"id\": \"approach\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#approach\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Approach\"), mdx(\"p\", null, \"We know that mathematically,\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \" n\", mdx(\"sup\", null, \"a.b\"), \" = (n\", mdx(\"sup\", null, \"a\"), \" )\", mdx(\"sup\", null, \" b \"), \" \"), \" \"), mdx(\"p\", null, \"So, let's suppose we have to find n\", mdx(\"sup\", null, \"x\"), \" and x = 2.y, so, we can find ( n \", mdx(\"sup\", null, \" 2 \"), \" ) \", mdx(\"sup\", null, \" y \"), \". \", mdx(\"br\", null), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"In y + 1 steps or x/2 + 1 steps\")), mdx(\"center\", null, \" \", mdx(\"b\", null, \" n\", mdx(\"sup\", null, \"2.y\"), \" = (n\", mdx(\"sup\", null, \"2\"), \" )\", mdx(\"sup\", null, \" y \"), \" \"), \" \"), \"Hence, we multiply n by itself, if x is even.\", mdx(\"p\", null, \"If, on the other hand, x is odd number \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"it is guaranteed that x-1 will be even number\"), \", hence, we multiply answer by n, if x is odd, and reduce x by 1.\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"algorithm\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#algorithm\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Algorithm\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If x <= 0, return 1.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If x is 1, return (answer * n) % p\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If x  > 1 and even, change n to n\", mdx(\"sup\", null, \"2\"), \", change x to x/2, and go to step 2\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If X > 1 and odd, multiply answer by n and store answer modulo p, and reduce x to x-1 and go to step 2.\")), mdx(\"h2\", {\n    \"id\": \"program-for-modular-exponentiation-in-rust\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#program-for-modular-exponentiation-in-rust\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Program for Modular Exponentiation in Rust\"), mdx(\"p\", null, \"Implementation of above algorithm is written below\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"\\nfn modular_exponent(mut n:i128 ,mut x:i128 , p:i128) -> i128{\\n    // Initialize ans = 1\\n    let mut ans = 1;\\n\\n    // x is 0, return 1\\n    if x<=0 {\\n        return 1;\\n    }\\n\\n    // use loop statement in rust for infinite loop\\n    loop {\\n        // Step 2. If x is 1, return (answer * n) % p\\n        if x==1 {\\n            return (ans * n) % p;\\n        }\\n\\n        // Step 3. If x > 1 and even, change n to n^2, change x to x/2, and go to step 2\\n\\n        // for checking if x is even, we check the LSB. is 0 or 1\\n        // Alternatively, we can also check x%2, but this is more efficient\\n        if x&1==0 {\\n            n=( n * n ) % p;\\n            x>>=1; // or x = x/2\\n            continue;\\n        }\\n\\n        // Step 4. If X > 1 and odd, multiply answer by n and store answer modulo p,\\n        // and reduce x to x-1 and go to step 2.\\n        else {\\n            ans = (ans*n) % p;\\n            x-=1;\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Input\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"2 \", mdx(\"br\", null), \"\\n100000 \", mdx(\"br\", null), \"\\n1000000007 \", mdx(\"br\", null))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"607723520\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity : O( log \", mdx(\"sub\", null, \" 2 \"), \" x)\"), \" \", mdx(\"br\", null), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Space Complexity : O( 1 )\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"Modular exponentiation is very frequently used concept in competitive programming for computing the answer.\\nIn this article, we made a program for modular exponentiation in rust in logarithmic time complexity instead of linear time complexity using Divide and Conquer approach. Here's the function for easy access\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"\\nfn modular_exponent(mut n:i128 ,mut x:i128 , p:i128) -> i128{\\n    let mut ans = 1;\\n    if x<=0 {\\n        return 1;\\n    }\\n    loop {\\n        if x==1 {\\n            return (ans * n) % p;\\n        }\\n        if x&1==0 {\\n            n=( n * n ) % p;\\n            x>>=1;\\n            continue;\\n        }\\n        else {\\n            ans = (ans*n) % p;\\n            x-=1;\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"Modular exponentiation is very frequently used concept in competitive programming. Here is the program for modular exponentiation in rust in logarithmic time complexity instead of linear using Divide and Conquer.\",\n    openGraph: {\n      description: 'Modular exponentiation is very frequently used concept in competitive programming. Here is the program for modular exponentiation in rust in logarithmic time complexity instead of linear using Divide and Conquer.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#modular-exponentiation-in-rust","title":"Modular Exponentiation in Rust","items":[{"url":"#what-is-modular-exponentiation","title":"What is Modular Exponentiation"},{"url":"#problem-statement","title":"Problem statement"},{"url":"#naive-approach","title":"Naive Approach"},{"url":"#efficient-divide-and-conquer-solution","title":"Efficient Divide and Conquer solution","items":[{"url":"#approach","title":"Approach"},{"url":"#algorithm","title":"Algorithm"}]},{"url":"#program-for-modular-exponentiation-in-rust","title":"Program for Modular Exponentiation in Rust"},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"bda3cd8e-1448-5b3c-856d-15a5e4422315"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","4275725850"]}