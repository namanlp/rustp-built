{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/number-theory/modular-multiplication/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Modular Arithmetic","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Modular Arithmetic\",\n  \"section\": \"2.1 Arithmetic Operations\",\n  \"order\": 1,\n  \"slug\": \"/number-theory/modular-multiplication/\",\n  \"description\": \"Many times, the results become so large that it becomes impossible to store them in any numerical data structure. This article covers basics of Modular Arithmetic.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"modular-arithmetic-in-rust\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#modular-arithmetic-in-rust\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Modular Arithmetic in Rust\"), mdx(\"p\", null, \"And basic properties with Examples\"), mdx(\"h2\", {\n    \"id\": \"what-is-modular-arithmetic\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-is-modular-arithmetic\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What is Modular Arithmetic\"), mdx(\"p\", null, \"From \", mdx(\"a\", {\n    target: \"_blank\",\n    rel: \"noreferrer noopener\",\n    href: \"https://en.wikipedia.org/wiki/Modular_arithmetic#:~:text=In%20mathematics%2C%20modular%20arithmetic%20is,Disquisitiones%20Arithmeticae%2C%20published%20in%201801.\"\n  }, \" Wikipedia \"), \":\"), mdx(\"p\", null, \"In Number Theory, modular arithmetic is a system of arithmetic for integers, where numbers \\\"wrap around\\\" when reaching a certain value, called the modulus.\"), mdx(\"p\", null, \"In Modular Arithmetic in competitive programming, we simply have to find answers modulo a given number. \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example :\"), \" Find remainder when 123 x 234 is divided by 10\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Solution :\"), \" 123 x 234 = 15252 and clearly, answer is 2, because we know that 15250 is divisible by 10\"), mdx(\"h2\", {\n    \"id\": \"need-of-modular-arithmetic\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#need-of-modular-arithmetic\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Need of Modular Arithmetic\"), mdx(\"p\", null, \"In many questions, the answer grow so large that it becomes impossible to store it in any numerical data structure, especially when answer is factorial, exponent, permutation or combination of a number.\"), mdx(\"p\", null, \"The largest numerical data structure in rust is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"i128\")), \" for integers, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"u128\")), \" for unsigned integers and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"f64\")), \" for decimals.\"), mdx(\"p\", null, \"Now, both \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"i128\")), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"u128\")), \" can store numbers upto order of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"10\\xB3\\u2078\")), \", which is pretty large, and both take 128 bits to represent.\"), mdx(\"p\", null, \"But now suppose you have to tell the answer of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\xB9\\u2070\\u2070\\u2070C\\u2085\\u2080\\u2080\"), \" , which is of order of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"10\\xB2\\u2079\\u2079\"), \" . Clearly it is impossible to calculate using traditional computation methods. Even if it is possible in certain languages like python, it takes really long time to compute it and is certainly not suitable for competitive programming.\"), mdx(\"p\", null, \"So, answers are judged on the basis of modulo of answer from a given a number, generally \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"10\\u2079 + 7 or 1000000007\")), \". So, it is necessary to know the properties of Modular Arithmetic and their application in order to compute the results efficiently.\"), mdx(\"h2\", {\n    \"id\": \"basic-properties\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#basic-properties\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Basic Properties\"), mdx(\"h3\", {\n    \"id\": \"1-addition-property\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#1-addition-property\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"1. Addition Property\"), mdx(\"p\", null, \"Mathematically,\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"), \" \"), mdx(\"p\", null, \"It can be extended to multiple numbers.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example :\"), \" Calculate remainder of 123 + 234 + 345 when divided by 45.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Solution :\"), mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" 123 mod 45 = 33 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" 234 mod 45 = 9 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" 345 mod 45 = 30 \", mdx(\"br\", null)), mdx(\"p\", null, \"\\xA0\", \" \", \"\\xA0\", \" So, ( 123 + 234 + 345 ) mod 45 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" = ( 33 + 9 + 30 ) mod 45 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" = \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"27\"), \" \", mdx(\"br\", null)), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Verifying :\"), \"\\n123 + 234 + 345 = 702 \", mdx(\"br\", null), \"\\nand 702 mod 45 = \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"27\"), \" \", mdx(\"br\", null)), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Hence Verified\")), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"2-multiplication-property\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#2-multiplication-property\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"2. Multiplication Property\"), mdx(\"p\", null, \"Mathematically,\"), mdx(\"center\", null, \" \", mdx(\"b\", null, \"(a x b) mod m = ((a mod m) x (b mod m)) mod m\"), \" \"), mdx(\"p\", null, \"It can also be extended to multiple numbers.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example :\"), \" Calculate remainder of 123 x 234 x 345 when divided by 47.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Solution :\"), mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" 123 mod 47 = 29 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" 234 mod 47 = 46 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" 345 mod 47 = 16 \", mdx(\"br\", null)), mdx(\"p\", null, \"\\xA0\", \" \", \"\\xA0\", \" So, ( 123 x 234 x 345 ) mod 47 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" = ( 29 x  46 x  16 ) mod 47 \", mdx(\"br\", null), \"\\n\", \"\\xA0\", \" \", \"\\xA0\", \" = \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"6\"), \" \", mdx(\"br\", null)), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Verifying :\"), \"\\n123 x 234 x 345 = 9929790 \", mdx(\"br\", null), \"\\nand 9929790 mod 47 = \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"6\"), \" \", mdx(\"br\", null)), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Hence Verified\")), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note :\"), \" There is no division property.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"This article covered basics of Modular Arithmetic.\"), mdx(\"p\", null, \"In the next few articles, we will see more advanced properties of Modular Arithmetic.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"Many times, the results become so large that it becomes impossible to store them in any numerical data structure. This article covers basics of Modular Arithmetic.\",\n    openGraph: {\n      description: 'Many times, the results become so large that it becomes impossible to store them in any numerical data structure. This article covers basics of Modular Arithmetic.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#modular-arithmetic-in-rust","title":"Modular Arithmetic in Rust","items":[{"url":"#what-is-modular-arithmetic","title":"What is Modular Arithmetic"},{"url":"#need-of-modular-arithmetic","title":"Need of Modular Arithmetic"},{"url":"#basic-properties","title":"Basic Properties","items":[{"url":"#1-addition-property","title":"1. Addition Property"},{"url":"#2-multiplication-property","title":"2. Multiplication Property"}]},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"a0282943-65ad-504a-82c3-79329787e1e5"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","4275725850"]}