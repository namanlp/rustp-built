{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/basic-programs/interactive-problems/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Solve Interactive Problems","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Solve Interactive Problems\",\n  \"section\": \"1. Basic Programs\",\n  \"order\": 90,\n  \"slug\": \"/basic-programs/interactive-problems/\",\n  \"description\": \"In competitive programming contests, Interactive Problems might be seen quite often. We will discuss flushing the buffer for these problems in Rust Language.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"solve-interactive-problems-in-rust\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#solve-interactive-problems-in-rust\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Solve Interactive Problems in Rust\"), mdx(\"p\", null, \"specifically for Competitive Programming in Rust\"), mdx(\"h2\", {\n    \"id\": \"introduction-to-interactive-problems\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#introduction-to-interactive-problems\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Introduction to Interactive problems\"), mdx(\"p\", null, \"In competitive programming contests, there can be a special type of problem called Interactive Problem. In these problems, the input is not predetermined. Rather, it is generated based on the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queries\"), \". Basically, your program \\\"sends\\\" the \\\"queries\\\" and the\\nOnline judge \\\"answers\\\" these queries, based on which, your program generates the final answer.\"), mdx(\"p\", null, \"And, queries are limited, off course, else the problems will be too easy.\"), mdx(\"p\", null, \"See  \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.codechef.com/problems/CHFIDEAL\"\n  }, \"Basic interactive problem on CodeChef\"), \" as an example.\"), mdx(\"h2\", {\n    \"id\": \"the-flush-issue\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-flush-issue\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"flush\"), \" Issue\"), mdx(\"p\", null, \"Actually, the output to terminal is an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"expensive\"), \" process for any programming language. If there are no buffers, each character will be shown as soon as output is generated. It will block the rest of the program thread for the time being, resulting in much slow execution of program.\\nSo, most of the modern programming languages make use of Buffer to store the output, and print the output later, block by block.\"), mdx(\"p\", null, \"But in the interactive problems, this is a major issue, because online judge will keep waiting indefinitely for the output, as it is stored in Buffer, and thus, no output will be generated, and the program keeps waiting for the output from online judge.\\nThis will result in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"deadlock\"), \" situation, and will result in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Limit Exceeded ( TLE )\"), \" verdict in most of the cases.\"), mdx(\"p\", null, \"So, we have to print  the contents of the buffer. This is called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"flushing\"), \". Formally, \", mdx(\"br\", null), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A buffer flush is the transfer of computer data from a temporary storage area to the computer\\u2019s permanent memory\")), mdx(\"h2\", {\n    \"id\": \"flush-in-rust\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#flush-in-rust\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"flush\"), \" in Rust\"), mdx(\"p\", null, \"From \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://doc.rust-lang.org/std/macro.print.html\"\n  }, \"Rust Documentation\"), \",\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"... stdout is frequently line-buffered by default ...\")), mdx(\"p\", null, \"So, if you use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"println!()\")), \", your output will automatically be printed as soon as you call it.\"), mdx(\"p\", null, \"Actually there are mainly 2 macros in Rust used for output, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"println!()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"print!()\"), \".\"), mdx(\"p\", null, \"As you might already know, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"println!()\"), \" macro ends with newline whereas the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"print!()\"), \" does not. So, after each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"println!()\"), \" statement, the buffer should automatically be cleared and output should be shown.\\nBut if you are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"print!()\"), \" statement, you must flush the output after each output statement.\"), mdx(\"p\", null, \"For explicitly flushing the output, you first have to import using\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io::{self, Write};\\n\")), mdx(\"p\", null, \"And then, use\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"io::stdout().flush().unwrap();\\n\")), mdx(\"p\", null, \"to flush.\"), mdx(\"h2\", {\n    \"id\": \"demonstrating-buffer\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#demonstrating-buffer\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Demonstrating Buffer\"), mdx(\"p\", null, \"For demonstrating the buffer, we make a simple program. In this, we first use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"println!()\"), \" , to show that it immediately flushes the output after each call.\"), mdx(\"p\", null, \"Then we add some \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"print!()\"), \" statements and sleep statements, so that we wait some time. As the output is stored in buffer, it is not printed till we flush the output.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::{thread, time};\\nuse std::io::{self, Write};\\n\\nfn main() {\\n    // Define one_second as 1 second of time\\n    let one_second = time::Duration::from_secs(1);\\n\\n    // println!() output will be flushed immediately\\n    println!(\\\"This is using println\\\");\\n\\n    // Now, demonstrating buffered output\\n\\n    // This is stored in buffer\\n    print!(\\\"This \\\");\\n    // This basically sleeps for 1 second\\n    thread::sleep(one_second);\\n\\n    print!(\\\"is \\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"not \\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"flushed \\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"yet.\\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"\\\\nFlushed now.....\\\");\\n\\n    // Flushing output\\n    io::stdout().flush().unwrap();\\n\\n\\n    print!(\\\"\\\\nHence \\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"the \\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"buffer \\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"contains \\\");\\n    thread::sleep(one_second);\\n\\n    print!(\\\"the string \\\");\\n    io::stdout().flush().unwrap();\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This is using println \", mdx(\"br\", null), \"\\nThis is not flushed yet. \", mdx(\"br\", null), \"\\nFlushed now..... \", mdx(\"br\", null), \"\\nHence the buffer contains the string\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note :\"), \" In this article, the timing of each output line matters more than the actual output. So, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"run it yourself!\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"In competitive programming contests, Interactive Problems might be seen quite often.  We discussed the problem with buffers and online judge in such problems as well as flushing the buffer in Rust.\"), mdx(\"p\", null, \"Now, with the given knowledge, try to submit the CodeChef problem given on the top of the page.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"In competitive programming contests, Interactive Problems might be seen quite often. We will discuss flushing the buffer for these problems in Rust Language.\",\n    openGraph: {\n      description: 'In competitive programming contests, Interactive Problems might be seen quite often. We will discuss flushing the buffer for these problems in Rust Language.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#solve-interactive-problems-in-rust","title":"Solve Interactive Problems in Rust","items":[{"url":"#introduction-to-interactive-problems","title":"Introduction to Interactive problems"},{"url":"#the-flush-issue","title":"The flush Issue"},{"url":"#flush-in-rust","title":"flush in Rust"},{"url":"#demonstrating-buffer","title":"Demonstrating Buffer"},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"69c0f311-530c-5b2c-92f0-2c045c53724a"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","3597609067"]}