{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/basic-programs/string-to-vector/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Convert String to Vector","editLink":""},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Convert String to Vector\",\n  \"section\": \"1. Basic Programs\",\n  \"order\": 3,\n  \"slug\": \"/basic-programs/string-to-vector/\",\n  \"description\": \"For many applications and competitive programming, it is very handy to have a function to input a string as a vector of characters. We make such a function here using chars() method.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"function-to-convert-string-to-vector-of-characters\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#function-to-convert-string-to-vector-of-characters\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Function to convert String to Vector of characters\"), mdx(\"p\", null, \"for competitive programming and more in Rust\"), mdx(\"h2\", {\n    \"id\": \"introduction\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#introduction\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Introduction\"), mdx(\"p\", null, \"For many applications, especially for many questions in competitive programming, ability to treat string like a vector or array of characters becomes immensely important.\\nIn many questions, you have to take input as a string and then perform certain operations on it like a vector.\"), mdx(\"p\", null, \"In many languages like C, C++ etc. you can easily index strings using square brackets [], just like vectors or arrays.\"), mdx(\"p\", null, \"In Rust, however, you can not index strings using square brackets, due to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"UTF-8 encoding\"), \". For example, the given code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"println!(\\\"{}\\\", string1[0]);\\n\")), mdx(\"p\", null, \"will give error\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"error[E0277]: the type `str` cannot be indexed by `{integer}`\\n\")), mdx(\"p\", null, \"or\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"error[E0277]: the type `str` cannot be indexed by `usize`\\n\")), mdx(\"p\", null, \"These operations are used very frequently in various applications, including competitive programming.\"), mdx(\"p\", null, \"So, if you are doing competitive programming in Rust, you should \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"include a function in your template\"), \" to take string as input, and return vector of chars, for easy access.\"), mdx(\"h2\", {\n    \"id\": \"why-rust-do-this\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#why-rust-do-this\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Why Rust do this\"), mdx(\"p\", null, \"The simple answer is to save space!\"), mdx(\"p\", null, \"Actually, Rust implements Unicode with UTF-8 encoding by default. UTF-8 tends to reduce the memory space occupied by string. But now, each character is of different length.\\nSo, it is impossible to get any character by index by simply going to that block, like we did in C / C++, because we can not simply guarantee how much characters are there in between.\"), mdx(\"p\", null, \"For example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is encoded as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"61\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\xA9\"), \" ( copyright sign ) is encoded as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C2 A9\"), \" in unicode. ( These are hexadecimal code )\"), mdx(\"p\", null, \"So, if we have a string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\\xA9a\"), \" = \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"61 C2 A9 61\"), \" , and try to access string\", \"[2]\", \" by incrementing 2 bytes in base address, it will return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A9\"), \" hexadecimal, which is invalid character.\"), mdx(\"p\", null, \"So, we have to traverse whole string and move only after checking unique prefixes.\"), mdx(\"h2\", {\n    \"id\": \"the-charsnth-method-and-tle\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-charsnth-method-and-tle\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \".chars().nth()\"), \" method and TLE\"), mdx(\"p\", null, \"Rust has a method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".chars()\"), \" , that is used to access string as chars. It takes \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( n )\"), \" time complexity, because it has to decode the complete string.\"), mdx(\"p\", null, \"Now, if we use, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".chars().nth(i).unwrap()\"), \" , it will run each time with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( n )\"), \" time complexity, which is very inefficient. Let us see a program using this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let string1 = \\\"Hello World\\\";\\n    println!(\\\"{}\\\", string1.chars().nth(0).unwrap());\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"H\")), mdx(\"p\", null, \"As seen above, it takes \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( n )\"), \" Time Complexity for accessing character each time. Hence, it results in TLE in competitive programming very often. We should be able to access each character in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( 1 )\"), \" or constant time complexity for each subsequent operations.\"), mdx(\"h2\", {\n    \"id\": \"converting-string-to-vector-of-characters\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#converting-string-to-vector-of-characters\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Converting String to Vector of Characters\"), mdx(\"p\", null, \"As seen above, if we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".chars().nth().unwrap()\"), \" method, it will take \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( N )\"), \" or linear time complexity \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"for each operation\"), \". So, let's say we have to print all the characters of the string. It will take \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( N \", mdx(\"sup\", null, \"2\"), \" )\"), \" or quadratic time complexity.\"), mdx(\"p\", null, \"But we can access each element of Vector using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( 1 )\"), \" or constant time complexity. So, printing all characters can be easily done in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O( N )\"), \" or Linear time complexity. We can convert string to vector of characters using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \".collect()\")), \" method.\"), mdx(\"p\", null, \"Program to demonstrate this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let string1 = \\\"Hello World\\\";\\n    let characters:Vec<char> = string1.chars().collect();\\n    println!(\\\"{:?}\\\", characters);\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']\")), mdx(\"h2\", {\n    \"id\": \"function-with-input\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#function-with-input\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Function with input\"), mdx(\"p\", null, \"Now, in competitive programming as well as other string manipulation programmes, most of the programmers will want a function, that will take string input and automatically convert it to vector and return vector of characters.\"), mdx(\"p\", null, \"Function for this is\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io;\\n\\nfn take_string() -> Vec<char> {\\n    // Initiate input variable\\n    let mut input = String::new();\\n\\n    // Read into input\\n    io::stdin().read_line(&mut input).unwrap();\\n\\n    // Convert input to vector of characters\\n    let vec:Vec<char> = input.trim().chars().collect();\\n\\n    // Return vector\\n    return vec;\\n}\\n\")), mdx(\"p\", null, \"With Driver code, this looks like\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io;\\n\\nfn take_string() -> Vec<char> {\\n    // Initiate input variable\\n    let mut input = String::new();\\n\\n    // Read into input\\n    io::stdin().read_line(&mut input).unwrap();\\n\\n    // Convert input to vector of characters\\n    let vec:Vec<char> = input.trim().chars().collect();\\n\\n    // Return vector\\n    return vec;\\n}\\n\\n// Driver code\\nfn main() {\\n    let str1 = take_string();\\n    println!(\\\"{:?}\\\", str1);\\n    println!(\\\"First and last characters : {} {}\\\", str1[0], str1[str1.len()-1]);\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Input\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This is rust programming\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Output\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"['T', 'h', 'i', 's', ' ', 'i', 's', ' ', 'r', 'u', 's', 't', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']\", \" \", mdx(\"br\", null), \"\\nFirst and last characters : T g\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"For many applications, especially for many questions in competitive programming, it is very handy to have a function to input a string as a vector of characters.\\nIn this article, we made such function to take input string from user and return Vector of characters.\"), mdx(\"p\", null, \"Here is function for easy access\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::io;\\n\\nfn take_string() -> Vec<char> {\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).unwrap();\\n    let vec:Vec<char> = input.trim().chars().collect();\\n    return vec;\\n}\\n\")), mdx(\"p\", null, \"This function should also be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"included in your template\"), \", if you are doing competitive programming in rust.\", mdx(\"br\", null), \"\\nAlso, we should also be able to convert array / vector of characters back to string. We shall discuss that in next article.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Thank You\")), mdx(GatsbySeo, {\n    description: \"For many applications and competitive programming, it is very handy to have a function to input a string as a vector of characters. We make such a function here using chars() method and also deal with TLE.\",\n    openGraph: {\n      description: 'For many applications and competitive programming, it is very handy to have a function to input a string as a vector of characters. We make such a function here using chars() method and also deal with TLE.'\n    },\n    mdxType: \"GatsbySeo\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#function-to-convert-string-to-vector-of-characters","title":"Function to convert String to Vector of characters","items":[{"url":"#introduction","title":"Introduction"},{"url":"#why-rust-do-this","title":"Why Rust do this"},{"url":"#the-charsnth-method-and-tle","title":"The .chars().nth() method and TLE"},{"url":"#converting-string-to-vector-of-characters","title":"Converting String to Vector of Characters"},{"url":"#function-with-input","title":"Function with input"},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"id":"2b276641-70cd-55fc-a695-f36565ed85a6"}},"staticQueryHashes":["1022386572","1122327541","1339625561","2140385554","4275725850"]}