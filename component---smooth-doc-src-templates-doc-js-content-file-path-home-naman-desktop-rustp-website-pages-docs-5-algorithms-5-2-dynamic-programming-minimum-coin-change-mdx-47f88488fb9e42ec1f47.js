"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[396],{33469:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var i=t(27378),a=t(20951),o=t(88957);function l(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",ol:"ol",li:"li",em:"em",h3:"h3",pre:"pre",code:"code",blockquote:"blockquote"},(0,a.ah)(),e.components);return i.createElement(i.Fragment,null,i.createElement(n.h1,{id:"minimum-coin-change-problem",style:{position:"relative"}},i.createElement(n.a,{href:"#minimum-coin-change-problem","aria-label":"minimum coin change problem permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Minimum Coin Change Problem"),"\n",i.createElement(n.p,null,"and space optimized Dynamic Programming Solution using tabulation and memoization in Rust Language."),"\n",i.createElement(n.h2,{id:"introduction",style:{position:"relative"}},i.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",i.createElement(n.p,null,"Minimum Coin change is another classical Dynamic Programming problem and is very similar to ",i.createElement(n.a,{href:"/dynamic-programming/coin-change/"},"Coin Change Problem"),"."),"\n",i.createElement(n.p,null,"In this problem, you are given coins of various denomination, and each coin has infinite supply."),"\n",i.createElement(n.p,null,"You have to tell ",i.createElement(n.strong,null,"Minimum number of coins")," that you can use to make the exact amount."),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"For Example :")," If coins are [1, 3, 4] and the amount is 6, the answer should be ",i.createElement(n.strong,null,"2"),", because you can form the sum using coins [3, 3]"),"\n",i.createElement(n.h2,{id:"recursive-solution",style:{position:"relative"}},i.createElement(n.a,{href:"#recursive-solution","aria-label":"recursive solution permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Recursive Solution"),"\n",i.createElement(n.p,null,"Recursive solution to this problem is pretty straightforward. At each step, you have 2 choices :"),"\n",i.createElement(n.ol,null,"\n",i.createElement(n.li,null,i.createElement(n.strong,null,"Exclude the given coin :")," We can exclude the given coin and find the answer with the remaining coins. In this, we simply call recursion using same amount, but n-1 coins."),"\n",i.createElement(n.li,null,i.createElement(n.strong,null,"Include the given coin :")," We can include the coin and again call recursion by reducing amount, but on same number of coins, because we can include and exclude same coin again."),"\n"),"\n",i.createElement(n.p,null,"We have to take minimum of both the cases."),"\n",i.createElement(n.p,null,"If amount is 0, we can form it using 0 coins."),"\n",i.createElement(n.p,null,"Also, if n is 0 and amount is not 0, we can not make the money. Hence, return Infinite value. We will take 10",i.createElement("sup",null,"10")," as our ",i.createElement(n.em,null,"infinite")," value for this question."),"\n",i.createElement(n.h3,{id:"function",style:{position:"relative"}},i.createElement(n.a,{href:"#function","aria-label":"function permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",i.createElement(n.p,null,"Here is the function using above algorithm"),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-rust"},"use std::cmp::min;\n\nfn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n\n    let infinite = 10_000_000_000;\n    // If amount is 0, we can make it without using coins\n    if amount == 0 { return 0; }\n\n    // If no coins left, but amount is not 0, we can not make the amount.\n    // Hence, return infinite value\n    if n==0 { return infinite; }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        return min_coin_change(coins, amount, n-1);\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the min_coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the min_coin_change of n items.\n    // Because we can include the coin again\n\n    // Return minimum of both cases.\n    return min(min_coin_change(coins, amount, n-1),1+min_coin_change(coins, amount-coins[n-1], n));\n}\n")),"\n",i.createElement(n.p,null,"With driver code"),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-rust"},'use std::cmp::min;\n\nfn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n\n    let infinite = 10_000_000_000;\n    // If amount is 0, we can make it without using coins\n    if amount == 0 { return 0; }\n\n    // If no coins left, but amount is not 0, we can not make the amount.\n    // Hence, return infinite value\n    if n==0 { return infinite; }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        return min_coin_change(coins, amount, n-1);\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the min_coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the min_coin_change of n items.\n    // Because we can include the coin again\n\n    // Return minimum of both cases.\n    return min(min_coin_change(coins, amount, n-1),1+min_coin_change(coins, amount-coins[n-1], n));\n}\n\n\n// Driver Code\n\nuse std::io;\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    let coins = take_vector();\n    let amount = take_vector()[0];\n    let ans  = min_coin_change(&coins, amount, coins.len());\n\n    // If answer is infinity, we have to print -1\n    if ans >= 1_000_000_000 { println!("-1"); }\n    else { println!("{}", ans); }\n}\n')),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Input")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"1 3 4 ",i.createElement("br"),"\n6"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Output")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"2"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Time Complexity : O( 2",i.createElement("sup",null,"n")," )")," ",i.createElement("br"),"\n",i.createElement(n.strong,null,"Space Complexity : O( n )")),"\n",i.createElement(n.p,null,"( Space complexity includes recursive stack space )"),"\n",i.createElement(n.h2,{id:"overlapping-sub-problems",style:{position:"relative"}},i.createElement(n.a,{href:"#overlapping-sub-problems","aria-label":"overlapping sub problems permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overlapping Sub-problems"),"\n",i.createElement(n.p,null,"If we have a look carefully on recursive approach, we computed multiple results many times."),"\n",i.createElement(n.p,null,"For example, if coins are [1, 2, 3, 6, 12] and amount is 24, the result for n = 2 and amount = 12 is calculated 4 times, and takes many recursions each time.\nThese are called overlapping sub-problems, because it is a sub-problem of actual problem and is overlapping in multiple recursions."),"\n",i.createElement(n.p,null,"To prevent this, we can store the output and each result will be calculated only once."),"\n",i.createElement(n.p,null,"In minimum coin change problem, we can create a dp matrix, and store each value by coin index and amount. That is, if we consider first ",i.createElement(n.code,null,"i")," coins, the result will be stored at dp[i][amount]."),"\n",i.createElement(n.p,null,"This is called memoization or Top-down Dynamic Programming."),"\n",i.createElement(n.h2,{id:"memoization--top-down-dp--method",style:{position:"relative"}},i.createElement(n.a,{href:"#memoization--top-down-dp--method","aria-label":"memoization  top down dp  method permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memoization ( Top-down DP ) Method"),"\n",i.createElement(n.p,null,"In memoization method, we simply take a DP matrix, and store the computed result."),"\n",i.createElement(n.h3,{id:"algorithm",style:{position:"relative"}},i.createElement(n.a,{href:"#algorithm","aria-label":"algorithm permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",i.createElement(n.ol,null,"\n",i.createElement(n.li,null,"If the stored value for given number of coins and amount in DP matrix is not ",i.createElement(n.code,null,"None"),", we return the value."),"\n",i.createElement(n.li,null,"If the amount is 0, return 0 and if n is 0 and amount > 0, return infinity."),"\n",i.createElement(n.li,null,"Else, use recursive logic to calculate the given value and store it in the DP matrix."),"\n"),"\n",i.createElement(n.h3,{id:"function-1",style:{position:"relative"}},i.createElement(n.a,{href:"#function-1","aria-label":"function 1 permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",i.createElement(n.p,null,"Here is the function using above algorithm"),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-rust"},"use std::cmp::min;\n\nfn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize, dp : &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    let infinite = 10_000_000_000;\n    // If amount is 0, we can make it without using coins\n    if amount == 0 { return 0; }\n\n    // If no coins left, but amount is not 0, we can not make the amount.\n    // Hence, return infinite value\n    if n==0 { return infinite; }\n\n    // If already computed the value, return it\n    if dp[n][amount].is_some() {\n        return dp[n][amount].unwrap();\n    }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        dp[n][amount] = Option::from(min_coin_change(coins, amount, n-1, dp));\n        return dp[n][amount].unwrap();\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the min_coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the min_coin_change of n items.\n    // Because we can include the coin again\n\n    // Return minimum of both cases.\n    dp[n][amount] =Option::from( min(min_coin_change(coins, amount, n-1, dp),1+min_coin_change(coins, amount-coins[n-1], n, dp)) );\n    return dp[n][amount].unwrap();\n}\n")),"\n",i.createElement(n.p,null,"With driver code"),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-rust"},'use std::cmp::min;\n\nfn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize, dp : &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    let infinite = 10_000_000_000;\n    // If amount is 0, we can make it without using coins\n    if amount == 0 { return 0; }\n\n    // If no coins left, but amount is not 0, we can not make the amount.\n    // Hence, return infinite value\n    if n==0 { return infinite; }\n\n    // If already computed the value, return it\n    if dp[n][amount].is_some() {\n        return dp[n][amount].unwrap();\n    }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        dp[n][amount] = Option::from(min_coin_change(coins, amount, n-1, dp));\n        return dp[n][amount].unwrap();\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the min_coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the min_coin_change of n items.\n    // Because we can include the coin again\n\n    // Return minimum of both cases.\n    dp[n][amount] =Option::from( min(min_coin_change(coins, amount, n-1, dp),1+min_coin_change(coins, amount-coins[n-1], n, dp)) );\n    return dp[n][amount].unwrap();\n}\n\n\n// Driver Code\n\nuse std::io;\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    let coins = take_vector();\n    let amount = take_vector()[0];\n\n    // Make a DP Matrix\n    // Initially set all the elements to None\n    let mut dp = vec![vec![Option::None; amount+1 ]; coins.len()+1];\n\n    let ans  = min_coin_change(&coins, amount, coins.len(), &mut dp);\n\n    // If answer is infinity, we have to print -1\n    if ans >= 1_000_000_000 { println!("-1"); }\n    else { println!("{}", ans); }\n}\n')),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Input")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"1 3 4 ",i.createElement("br"),"\n6"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Output")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"2"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Time Complexity : O( n×amount )")," ",i.createElement("br"),"\n",i.createElement(n.strong,null,"Space Complexity : O( n×amount )")),"\n",i.createElement(n.h2,{id:"tabulation---bottom-up-dp---method",style:{position:"relative"}},i.createElement(n.a,{href:"#tabulation---bottom-up-dp---method","aria-label":"tabulation   bottom up dp   method permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tabulation  ( Bottom-up DP )  Method"),"\n",i.createElement(n.p,null,"Although time and space complexities of tabulation as well as memoization method are same, tabulation is much more efficient as there are a lot of expensive recursive calls in memoization."),"\n",i.createElement(n.p,null,"In tabulation method, we make the matrix, and fill it first on the basis of base condition, and then on the basis of previous row."),"\n",i.createElement(n.h3,{id:"algorithm-1",style:{position:"relative"}},i.createElement(n.a,{href:"#algorithm-1","aria-label":"algorithm 1 permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",i.createElement(n.ol,null,"\n",i.createElement(n.li,null,"Initially, set first row to infinity, because if n == 0, we can not make amount, except when amount = 0.  Also, set first column as ",i.createElement(n.strong,null,"0"),", because if amount is 0, there is always amount can be formed in 1 step."),"\n",i.createElement(n.li,null,"For all the amount for a given value of n, run below statement 3 and 4."),"\n",i.createElement(n.li,null,"Set the values before the coin value as copied from above row, because we can not include a coin if its value is less than the amount."),"\n",i.createElement(n.li,null,"Set the value of dp[i][amount] as minimum of including and excluding the given coin."),"\n",i.createElement(n.li,null,"Return the dp[n][amount] as the final answer."),"\n"),"\n",i.createElement(n.h3,{id:"function-2",style:{position:"relative"}},i.createElement(n.a,{href:"#function-2","aria-label":"function 2 permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",i.createElement(n.p,null,"Here is the function using above algorithm"),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-rust"},"use std::cmp::min;\n\nfn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n\n    // Initially, set whole matrix to infinity\n    let infinite = 10_000_000_000;\n    let mut dp = vec![vec![infinite; amount+1]; n+1];\n\n    // Set the first column to 0, because if amount is 0, we can make the amount\n    for i in 0..n+1 { dp[i][0] = 0; }\n\n    // Run loop for all the i from 1 to n\n    for i in 1..n+1 {\n        // Run loop for each amount below coins[n-1], set above row\n        for j in 1..min(coins[i-1], amount+1){ dp[i][j] = dp[i-1][j]; }\n\n        // Now, for larger amount, we can both include and exclude.\n        // So, we take minimum of both cases\n        for j in coins[i-1]..amount+1 {\n            dp[i][j] = min(1+dp[i][j-coins[i-1]] , dp[i-1][j]);\n        }\n    }\n\n    // Return The answer\n    dp[n][amount]\n}\n")),"\n",i.createElement(n.p,null,"Use the same driver code as recursive solution."),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Input")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"1 3 4 ",i.createElement("br"),"\n6"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Output")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"2"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Time Complexity : O( n×amount )")," ",i.createElement("br"),"\n",i.createElement(n.strong,null,"Space Complexity : O( n×amount )")),"\n",i.createElement(n.h2,{id:"space-optimized-tabulation-method",style:{position:"relative"}},i.createElement(n.a,{href:"#space-optimized-tabulation-method","aria-label":"space optimized tabulation method permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Space Optimized Tabulation Method"),"\n",i.createElement(n.p,null,"If we observe the above tabulation method carefully, we find that for calculating the minimum coin change for a given amount and number of coins, only ",i.createElement(n.strong,null,"current and previous row")," is required."),"\n",i.createElement(n.p,null,"In the above algorithm, step 1 is base case or initialization step, and do not require any other row."),"\n",i.createElement(n.p,null,"Step 3 and Step 4 requires only previous and current row."),"\n",i.createElement(n.p,null,"Hence, we can optimize our space complexity, by storing only the previous row instead of the whole matrix."),"\n",i.createElement(n.h3,{id:"function-3",style:{position:"relative"}},i.createElement(n.a,{href:"#function-3","aria-label":"function 3 permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",i.createElement(n.p,null,"Here is the function using space optimization of tabulation method."),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-rust"},"use std::cmp::min;\n\nfn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n\n    // Initially, set previous as well as current to infinity\n    let infinite = 10_000_000_000;\n\n    let mut prev = vec![infinite; amount+1];\n    let mut curr = vec![infinite; amount+1];\n\n    // Set the first column to 0, because if amount is 0, we can make the amount\n    prev[0] = 0;\n    curr[0] = 0;\n\n    // Run loop for all the i from 1 to n\n    for i in 1..n+1 {\n        // Run loop for each amount below coins[n-1], set above row\n        for j in 1..min(coins[i-1], amount+1){ curr[j] = prev[j]; }\n\n        // Now, for larger amount, we can both include and exclude.\n        // So, we take minimum of both cases\n        for j in coins[i-1]..amount+1 {\n            curr[j] = min(1+curr[j-coins[i-1]] , prev[j]);\n        }\n\n        // Move the elements from current to previous\n        for j in 0..amount+1 { prev[j] = curr[j];}\n    }\n\n    // Return The answer\n    curr[amount]\n}\n")),"\n",i.createElement(n.p,null,"Use the same driver code as recursive solution."),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Input")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"1 3 4 ",i.createElement("br"),"\n6"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Output")),"\n",i.createElement(n.blockquote,null,"\n",i.createElement(n.p,null,"2"),"\n"),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Time Complexity : O( n×amount )")," ",i.createElement("br"),"\n",i.createElement(n.strong,null,"Space Complexity : O( amount )")),"\n",i.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},i.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},i.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",i.createElement(n.p,null,"Minimum Coin change is another classical Dynamic Programming problem and is very similar to ",i.createElement(n.a,{href:"/dynamic-programming/coin-change/"},"Coin Change Problem"),"."),"\n",i.createElement(n.p,null,"In this problem, you are given coins of various denomination, and each coin has infinite supply."),"\n",i.createElement(n.p,null,"You have to tell ",i.createElement(n.strong,null,"Minimum number of coins")," that you can use to make the exact amount."),"\n",i.createElement(n.p,null,"In this article, we saw how to solve the minimum coin change problem, first using recursion and then using Dynamic Programming, memoization as well as tabulation method, and latter the space optimized tabulation method in Rust Language."),"\n",i.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-rust"},"use std::cmp::min;\nfn min_coin_change(coins:&Vec<usize>, amt : usize, n:usize) -> usize{\n    let inf = 10_000_000_000;\n    let mut p = vec![inf; amt+1];\n    let mut c = vec![inf; amt+1];\n    p[0] = 0; c[0] = 0;\n    for i in 1..n+1 {\n        for j in 1..min(coins[i-1], amt+1){ c[j] = p[j]; }\n        for j in coins[i-1]..amt+1 { c[j] = min(1+c[j-coins[i-1]] , p[j]); }\n        for j in 0..amt+1 { p[j] = c[j];}\n    }\n    c[amt]\n}\n")),"\n",i.createElement(n.p,null,i.createElement(n.strong,null,"Thank You")),"\n","\n",i.createElement(o.H,{title:"Minimum Coin Change with Space Optimization - DP - Rust Programming",description:"Tell minimum number of coins to make exact amount. We will see recursion, memoization, tabulation and space optimized DP solution in Rust Language.",img:"https://rustp.org/Static_Images_DND/Social/Min_Coin_Change_Social.png"}))}var c=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?i.createElement(n,e,i.createElement(l,e)):l(e)};function r(e){return e.children}function u(e){return i.createElement(r,e,i.createElement(c,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-2-dynamic-programming-minimum-coin-change-mdx-47f88488fb9e42ec1f47.js.map