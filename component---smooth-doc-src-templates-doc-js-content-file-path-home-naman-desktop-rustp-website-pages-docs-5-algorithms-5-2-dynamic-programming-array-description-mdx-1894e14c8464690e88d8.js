"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[913],{59981:function(e,n,t){t.r(n),t.d(n,{default:function(){return c}});var a=t(27378),l=t(20951),r=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",ol:"ol",li:"li",code:"code",h3:"h3",pre:"pre",blockquote:"blockquote"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h1,{id:"array-description",style:{position:"relative"}},a.createElement(n.a,{href:"#array-description","aria-label":"array description permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Array Description"),"\n",a.createElement(n.p,null,"and space optimized Dynamic Programming Solution using tabulation and memoization in Rust Language."),"\n",a.createElement(n.h2,{id:"introduction",style:{position:"relative"}},a.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",a.createElement(n.p,null,"Array Description is another Dynamic Programming Problem taken from CSES problem set. Here is ",a.createElement("a",{href:"https://cses.fi/problemset/task/1746"}," Array Description Problem Link ")),"\n",a.createElement(n.p,null,"In this question you are given an array with missing values and some conditions. You have to determine the number of possible arrays following those conditions."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Conditions are :")),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Absolute difference between two adjacent values is at most 1."),"\n",a.createElement(n.li,null,"Each element in the array must be in range 1 to m."),"\n"),"\n",a.createElement(n.p,null,"You are given the value of n, m and the array, in which missing numbers are represented by ",a.createElement(n.code,null,"0"),", and other numbers are between 1 and m."),"\n",a.createElement(n.p,null,"You have to tell the number of possible arrays that follow the above conditions. Since the answer may be very large, you have to tell the answer modulo 10",a.createElement("sup",null,"9 "),"+7"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"For Example :")," If the array is [2, 1, 0] and the m is 100, the answer will be 2 as the arrays can be [2, 1, 1] and [2, 1, 2]."),"\n",a.createElement(n.h2,{id:"recursive-solution",style:{position:"relative"}},a.createElement(n.a,{href:"#recursive-solution","aria-label":"recursive solution permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Recursive Solution"),"\n",a.createElement(n.p,null,"In the solution to this problem, we apply an observation."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Observation :")," If the value of the last element of the array is fixed, say ",a.createElement(n.code,null,"x"),",  there can be only three values of last second element, that is ",a.createElement(n.code,null,"x-1"),", ",a.createElement(n.code,null,"x")," and ",a.createElement(n.code,null,"x+1"),". Similarly, we can count the cases of last third element and so on till we reach first element."),"\n",a.createElement(n.p,null,"We can apply this observation to solve this problem."),"\n",a.createElement(n.h3,{id:"algorithm",style:{position:"relative"}},a.createElement(n.a,{href:"#algorithm","aria-label":"algorithm permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",a.createElement(n.p,null,"If the last element of array is ",a.createElement(n.code,null,"0"),", count the cases for all values of last element from 1 to m. Here is the function to count possible arrays."),"\n",a.createElement(n.p,null,"Function takes the original array, index to check, m and value to check as input and return the number of possible cases for the array."),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"If the value to check is not in range of 1 to m, return 0."),"\n",a.createElement(n.li,null,"If the given index of array is non 0, and not equal to the given value, return 0, because can not be possible."),"\n",a.createElement(n.li,null,"Now, it is certainly possible to create an array using these values."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Base Case :")," If the index is 0, return 1, because we can set the first element to given value. Hence 1 case."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Recursive Case :")," Else, return the cases by setting previous element to given ",a.createElement(n.code,null,"value-1"),", ",a.createElement(n.code,null,"value")," and ",a.createElement(n.code,null,"value+1"),"."),"\n"),"\n",a.createElement(n.h3,{id:"function",style:{position:"relative"}},a.createElement(n.a,{href:"#function","aria-label":"function permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using above algorithm"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"\nfn count_arrays(arr:&Vec<usize>, index:usize, m:usize, value:usize) -> usize{\n\n    // If value is not between 1 and m, no possible case\n    if value >m || value < 1 { return 0; }\n\n    // Now, if the array's given index value is already non 0\n    // And not equal to the checked value, no possible case\n    if arr[index] != 0 && arr[index] != value { return 0; }\n\n    // Now, in either case, we can set the given value to the given index.\n    // Hence, count the cases after setting given index to value\n\n    // Base Case, if the first element is to be checked, return 1\n    // Because if arr[0] == 0, only 1 possible case, that is set the value\n    // Or if arr[0] == value, still only 1 case\n    if index == 0 { return 1; }\n\n\n    // Now cases are counted by recursively calling the function\n    // For index -1, and values x-1, x, x+1\n    // It is guaranteed that the value returned by each function\n    // is not greater than 10^9+7. So, we add them and return their modulo 10^9+7\n\n    return (count_arrays(arr, index-1, m, value-1) +\n        count_arrays(arr, index-1, m, value) +\n        count_arrays(arr, index-1, m, value+1)) % 1_000_000_007;\n}\n")),"\n",a.createElement(n.p,null,"With Driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'\n\nfn count_arrays(arr:&Vec<usize>, index:usize, m:usize, value:usize) -> usize{\n\n    // If value is not between 1 and m, no possible case\n    if value >m || value < 1 { return 0; }\n\n    // Now, if the array\'s given index value is already non 0\n    // And not equal to the checked value, no possible case\n    if arr[index] != 0 && arr[index] != value { return 0; }\n\n    // Now, in either case, we can set the given value to the given index.\n    // Hence, count the cases after setting given index to value\n\n    // Base Case, if the first element is to be checked, return 1\n    // Because if arr[0] == 0, only 1 possible case, that is set the value\n    // Or if arr[0] == value, still only 1 case\n    if index == 0 { return 1; }\n\n\n    // Now cases are counted by recursively calling the function\n    // For index -1, and values x-1, x, x+1\n    // It is guaranteed that the value returned by each function\n    // is not greater than 10^9+7. So, we add them and return their modulo 10^9+7\n\n    return (count_arrays(arr, index-1, m, value-1) +\n        count_arrays(arr, index-1, m, value) +\n        count_arrays(arr, index-1, m, value+1)) % 1_000_000_007;\n}\n\n// Driver code\n\n// Take array input\nuse std::io;\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    // Input n and m\n    let n_m = take_vector();\n    let n = n_m[0];\n    let m = n_m[1];\n\n    // Take array\n    let arr = take_vector();\n\n    // Take sum of all the possible values.\n    // Now, we know that usize can easily store numbers upto 10^18\n    // So, we take modulo at the end.\n\n    let mut ans = 0;\n\n    // We take all possible value of last element.\n    // If last element is non zero, other values will be rejected\n    for i in 1..m+1 {\n        ans+=count_arrays(&arr, n-1, m, i);\n    }\n\n    println!("{}", ans% 1_000_000_007);\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"3 100 ",a.createElement("br"),"\n2 1 0"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"2"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( 3",a.createElement("sup",null,"n")," )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( n )")),"\n",a.createElement(n.p,null,"( Space complexity includes recursive stack space )"),"\n",a.createElement(n.h2,{id:"overlapping-sub-problems",style:{position:"relative"}},a.createElement(n.a,{href:"#overlapping-sub-problems","aria-label":"overlapping sub problems permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overlapping Sub-problems"),"\n",a.createElement(n.p,null,"If we have a look carefully on recursive approach, we computed multiple results many times."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"For example :"),"  If ",a.createElement(n.code,null,"m")," = 100 and array is [0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0], we can reach the element 50 in thousands of ways, and takes thousands of recursions each time to calculate."),"\n",a.createElement(n.p,null,"These are called ",a.createElement(n.strong,null,"Overlapping Sub-problems")," because they are smaller part of large problems, and are computed again and again."),"\n",a.createElement(n.p,null,"So, we simply calculate them once, and store them in a matrix, and retrieve them when necessary. This helps to save a lot of computation."),"\n",a.createElement(n.p,null,"This is called Memoization Dynamic Programming Approach for the problem."),"\n",a.createElement(n.h2,{id:"memoization--top-down-dp--method",style:{position:"relative"}},a.createElement(n.a,{href:"#memoization--top-down-dp--method","aria-label":"memoization  top down dp  method permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memoization ( Top-down DP ) Method"),"\n",a.createElement(n.p,null,"In memoization method, we simply take a DP matrix, and store the computed result."),"\n",a.createElement(n.h3,{id:"algorithm-1",style:{position:"relative"}},a.createElement(n.a,{href:"#algorithm-1","aria-label":"algorithm 1 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Initially, take a DP matrix and set all its elements to ",a.createElement(n.code,null,"None")," type. Alternatively, you can set it to -1."),"\n",a.createElement(n.li,null,"If the possible arrays for given index and value is already computed, return it."),"\n",a.createElement(n.li,null,"Else, calculate the value using recursion, and store it in DP matrix, and return it."),"\n"),"\n",a.createElement(n.h3,{id:"function-1",style:{position:"relative"}},a.createElement(n.a,{href:"#function-1","aria-label":"function 1 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using above algorithm"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn count_arrays(arr:&Vec<usize>, index:usize, m:usize, value:usize, dp: &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    // If value is not between 1 and m, no possible case\n    if value >m || value < 1 { return 0; }\n\n    // If already computed the value, return it\n    if dp[index][value].is_some() { return dp[index][value].unwrap(); }\n\n    // Now, if the array's given index value is already non 0\n    // And not equal to the checked value, no possible case\n    if arr[index] != 0 && arr[index] != value { dp[index][value] = Option::from(0); return 0; }\n\n    // Now, in either case, we can set the given value to the given index.\n    // Hence, count the cases after setting given index to value\n\n    // Base Case, if the first element is to be checked, return 1\n    // Because if arr[0] == 0, only 1 possible case, that is set the value\n    // Or if arr[0] == value, still only 1 case\n    if index == 0 { dp[index][value] = Option::from(1); return 1; }\n\n\n    // Now cases are counted by recursively calling the function\n    // For index -1, and values x-1, x, x+1\n    // It is guaranteed that the value returned by each function\n    // is not greater than 10^9+7. So, we add them and return their modulo 10^9+7\n\n    dp[index][value] = Option::from(  (count_arrays(arr, index-1, m, value-1, dp) +\n        count_arrays(arr, index-1, m, value, dp) +\n        count_arrays(arr, index-1, m, value+1, dp)) % 1_000_000_007);\n    return dp[index][value].unwrap();\n}\n")),"\n",a.createElement(n.p,null,"With Driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'\n\nfn count_arrays(arr:&Vec<usize>, index:usize, m:usize, value:usize, dp: &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    // If value is not between 1 and m, no possible case\n    if value >m || value < 1 { return 0; }\n\n    // If already computed the value, return it\n    if dp[index][value].is_some() { return dp[index][value].unwrap(); }\n\n    // Now, if the array\'s given index value is already non 0\n    // And not equal to the checked value, no possible case\n    if arr[index] != 0 && arr[index] != value { dp[index][value] = Option::from(0); return 0; }\n\n    // Now, in either case, we can set the given value to the given index.\n    // Hence, count the cases after setting given index to value\n\n    // Base Case, if the first element is to be checked, return 1\n    // Because if arr[0] == 0, only 1 possible case, that is set the value\n    // Or if arr[0] == value, still only 1 case\n    if index == 0 { dp[index][value] = Option::from(1); return 1; }\n\n\n    // Now cases are counted by recursively calling the function\n    // For index -1, and values x-1, x, x+1\n    // It is guaranteed that the value returned by each function\n    // is not greater than 10^9+7. So, we add them and return their modulo 10^9+7\n\n    dp[index][value] = Option::from(  (count_arrays(arr, index-1, m, value-1, dp) +\n        count_arrays(arr, index-1, m, value, dp) +\n        count_arrays(arr, index-1, m, value+1, dp)) % 1_000_000_007);\n    return dp[index][value].unwrap();\n}\n\n// Driver code\n\n// Take array input\nuse std::io;\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    // Input n and m\n    let n_m = take_vector();\n    let n = n_m[0];\n    let m = n_m[1];\n\n    // Take array\n    let arr = take_vector();\n\n    // Take sum of all the possible values.\n    // Now, we know that usize can easily store numbers upto 10^18\n    // So, we take modulo at the end.\n\n    let mut ans = 0;\n\n    // DP matrix has m+1 columns because value of each element is at max m\n    // And there are n elements in array, so n rows.\n    let mut dp = vec![vec![None; m+1]; n];\n\n    // We take all possible value of last element.\n    // If last element is non zero, other values will be rejected\n    for i in 1..m+1 {\n        ans+=count_arrays(&arr, n-1, m, i, &mut dp);\n    }\n\n    println!("{}", ans% 1_000_000_007);\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"3 100 ",a.createElement("br"),"\n2 1 0"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"2"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( m×n )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( m×n )")),"\n",a.createElement(n.h2,{id:"tabulation---bottom-up-dp---method",style:{position:"relative"}},a.createElement(n.a,{href:"#tabulation---bottom-up-dp---method","aria-label":"tabulation   bottom up dp   method permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tabulation  ( Bottom-up DP )  Method"),"\n",a.createElement(n.p,null,"Although time and space complexities of tabulation as well as memoization method are same, tabulation is much more efficient as there are a lot of expensive recursive calls in memoization."),"\n",a.createElement(n.p,null,"In tabulation method, we make the DP matrix, and fill it first on the basis of base condition, and then on the basis of previous row."),"\n",a.createElement(n.h3,{id:"algorithm-2",style:{position:"relative"}},a.createElement(n.a,{href:"#algorithm-2","aria-label":"algorithm 2 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Initially, if the value of first element is 0, set first row to 1, because only 1 possible case. Else, set first row to 0, except the value of first element."),"\n",a.createElement(n.li,null,"For each element, if the value is non-zero, say x, then compute only cases for x, and set other to zero. Else, compute cases for all values from 1 to m."),"\n",a.createElement(n.li,null,"To compute values for given element, simply take sum of ",a.createElement(n.code,null,"x-1"),", ",a.createElement(n.code,null,"x")," and ",a.createElement(n.code,null,"x+1")," from previous row."),"\n",a.createElement(n.li,null,"Finally, return the sum of elements of last row as the answer."),"\n"),"\n",a.createElement(n.h3,{id:"function-2",style:{position:"relative"}},a.createElement(n.a,{href:"#function-2","aria-label":"function 2 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using above algorithm"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn count_arrays(arr:&Vec<usize>, m:usize) -> usize{\n\n    // init dp matrix as all 0\n    // We take m+2 columns so that 0 and m+1 are always 0.\n    let mut dp = vec![vec![0; m+2]; arr.len()];\n\n    // If first element is 0, set first row to 1, else set only value to 1\n    // Rest of elements are automatically set to 0\n    if arr[0] == 0 { for i in 1..m+1 { dp[0][i] = 1;} }\n    else { dp[0][arr[0]] = 1; }\n\n    // For each subsequent row, if the element is 0, compute cases for each value\n    // from 1 to m. Else for the given element only.\n    for i in 1..arr.len() {\n        if arr[i] == 0 {\n            // The 0 and m+1 element in dp array is always 0, hence no issue.\n            for j in 1..m+1 { dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1])%1_000_000_007;}\n        }\n        else {\n            let val = arr[i];\n            dp[i][val] = (dp[i-1][val-1] + dp[i-1][val] + dp[i-1][val+1])%1_000_000_007;}\n    }\n\n    // Finally, return the sum of all elements\n\n    let mut sum = 0;\n    for i in 1..m+1 { sum+=dp[arr.len()-1][i]; }\n    return sum%1_000_000_007;\n}\n")),"\n",a.createElement(n.p,null,"With Driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'\n\nfn count_arrays(arr:&Vec<usize>, m:usize) -> usize{\n\n    // init dp matrix as all 0\n    // We take m+2 columns so that 0 and m+1 are always 0.\n    let mut dp = vec![vec![0; m+2]; arr.len()];\n\n    // If first element is 0, set first row to 1, else set only value to 1\n    // Rest of elements are automatically set to 0\n    if arr[0] == 0 { for i in 1..m+1 { dp[0][i] = 1;} }\n    else { dp[0][arr[0]] = 1; }\n\n    // For each subsequent row, if the element is 0, compute cases for each value\n    // from 1 to m. Else for the given element only.\n    for i in 1..arr.len() {\n        if arr[i] == 0 {\n            // The 0 and m+1 element in dp array is always 0, hence no issue.\n            for j in 1..m+1 { dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1])%1_000_000_007;}\n        }\n        else {\n            let val = arr[i];\n            dp[i][val] = (dp[i-1][val-1] + dp[i-1][val] + dp[i-1][val+1])%1_000_000_007;}\n    }\n\n    // Finally, return the sum of all elements\n\n    let mut sum = 0;\n    for i in 1..m+1 { sum+=dp[arr.len()-1][i]; }\n    return sum%1_000_000_007;\n}\n\n// Driver code\n\n// Take array input\nuse std::io;\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    // Input n and m\n    let n_m = take_vector();\n    let m = n_m[1];\n\n    // Take array\n    let arr = take_vector();\n\n    println!("{}", count_arrays(&arr, m));\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"3 100 ",a.createElement("br"),"\n2 1 0"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"2"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( m×n )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( m×n )")),"\n",a.createElement(n.h2,{id:"space-optimized-tabulation-method",style:{position:"relative"}},a.createElement(n.a,{href:"#space-optimized-tabulation-method","aria-label":"space optimized tabulation method permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Space Optimized Tabulation Method"),"\n",a.createElement(n.p,null,"If we observe the above tabulation method carefully, we find that for calculating the value for each ",a.createElement(n.code,null,"n"),", only the previous row values are needed."),"\n",a.createElement(n.p,null,"Hence, we can optimize our space complexity, by storing only the previous row and not the whole matrix."),"\n",a.createElement(n.h3,{id:"function-3",style:{position:"relative"}},a.createElement(n.a,{href:"#function-3","aria-label":"function 3 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using space optimization of tabulation method."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"\nfn count_arrays(arr:&Vec<usize>, m:usize) -> usize{\n    // Initially, both current and finally are all 0 vector\n    let mut prev = vec![0; m+2];\n    let mut curr = vec![0; m+2];\n\n    // Base case, If first element is 0, set first row to 1, else set only value to 1\n    // Rest of elements are automatically set to 0\n    if arr[0] == 0 { for i in 1..m+1 { prev[i] = 1;} }\n    else { prev[arr[0]] = 1; }\n\n    // For each subsequent row, if the element is 0, compute cases for each value\n    // from 1 to m. Else for the given element only.\n    for i in 1..arr.len() {\n        if arr[i] == 0 {\n            // The 0 and m+1 element in dp array is always 0, hence no issue.\n            for j in 1..m+1 { curr[j] = (prev[j-1] + prev[j] + prev[j+1])%1_000_000_007;}\n        }\n        else {\n            let val = arr[i];\n            curr[val] = (prev[val-1] + prev[val] + prev[val+1])%1_000_000_007;}\n\n        // Move the current values to previous vector\n        // And set current vector to 0\n        for j in 0..m+2 {prev[j] = curr[j]; curr[j] = 0;}\n    }\n\n    // Finally, return the sum of all elements of previous\n    // Because current is cleared and its element are already in prev\n    let mut sum = 0;\n    for i in 1..m+1 { sum+=prev[i]; }\n    return sum%1_000_000_007;\n}\n")),"\n",a.createElement(n.p,null,"Use the same driver code."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"3 100 ",a.createElement("br"),"\n2 1 0"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"2"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( m×n )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( m )")),"\n",a.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},a.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",a.createElement(n.p,null,"Array Description is a Dynamic Programming Problem taken from CSES problem set."),"\n",a.createElement(n.p,null,"In this question you are given an array with missing values. You have to determine the number of possible arrays such that absolute difference of each adjacent elements is at most 1."),"\n",a.createElement(n.p,null,"Also, each element must be in range 1 to m."),"\n",a.createElement(n.p,null,"In this article, we saw how to solve the Array Description problem, first using recursion and then using Dynamic Programming, memoization as well as tabulation method, and latter the space optimized tabulation method in Rust Language."),"\n",a.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn count_arrays(arr:&Vec<usize>, m:usize) -> usize{\n    let mut prev = vec![0; m+2];\n    let mut curr = vec![0; m+2];\n    if arr[0] == 0 { for i in 1..m+1 { prev[i] = 1;} }\n    else { prev[arr[0]] = 1; }\n\n    for i in 1..arr.len() {\n        if arr[i] == 0 { for j in 1..m+1 { curr[j] = (prev[j-1] + prev[j] + prev[j+1])%1_000_000_007;} }\n        else { let val = arr[i];curr[val] = (prev[val-1] + prev[val] + prev[val+1])%1_000_000_007;}\n\n        for j in 0..m+2 {prev[j] = curr[j]; curr[j] = 0;}\n    }\n    let mut sum = 0; for i in 1..m+1 { sum+=prev[i]; }\n    return sum%1_000_000_007;\n}\n")),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Thank You")),"\n","\n",a.createElement(r.H,{title:"Array Description Problem using Recursion, Memoization and Tabulation and Space Optimization - Dynamic Programming - Rust Programming",description:"Determine the number of possible arrays, absolute difference of adjacent elements is at most 1. We will see recursive, memoization, tabulation and space optimized DP solution in Rust Language."}))}var o=function(e){void 0===e&&(e={});var n=Object.assign({},(0,l.ah)(),e.components).wrapper;return n?a.createElement(n,e,a.createElement(i,e)):i(e)};function s(e){return e.children}function c(e){return a.createElement(s,e,a.createElement(o,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-2-dynamic-programming-array-description-mdx-1894e14c8464690e88d8.js.map