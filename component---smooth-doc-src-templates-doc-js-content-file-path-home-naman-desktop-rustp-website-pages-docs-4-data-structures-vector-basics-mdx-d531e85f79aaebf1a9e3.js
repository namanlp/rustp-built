"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7959],{78728:function(e,t,n){n.r(t),n.d(t,{default:function(){return s}});var a=n(27378),l=n(20951),c=n(88957);function r(e){var t=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",em:"em",code:"code",strong:"strong",pre:"pre",blockquote:"blockquote",h3:"h3",ol:"ol",li:"li",ul:"ul"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.h1,{id:"introduction-to-vectors",style:{position:"relative"}},a.createElement(t.a,{href:"#introduction-to-vectors","aria-label":"introduction to vectors permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction to Vectors"),"\n",a.createElement(t.p,null,"and the basic vector functions in Rust"),"\n",a.createElement(t.h2,{id:"1-introduction",style:{position:"relative"}},a.createElement(t.a,{href:"#1-introduction","aria-label":"1 introduction permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1. Introduction"),"\n",a.createElement(t.p,null,"From ",a.createElement(t.a,{href:"https://doc.rust-lang.org/std/vec/struct.Vec.html"},"Rust standard library documentation On Vectors"),", we define vectors as ",a.createElement(t.em,null,"contiguous growable array type"),".\nThey are represented as ",a.createElement(t.code,null,"Vec<T>")," , where the vector contains multiple instances of type ",a.createElement(t.strong,null,a.createElement(t.code,null,"T")),".\n",a.createElement(t.strong,null,a.createElement(t.code,null,"T"))," can be any data type, like ",a.createElement(t.code,null,"usize"),", ",a.createElement(t.code,null,"i128")," or other class / structs, for example ",a.createElement(t.code,null,"Hashmap<usize, usize>")," or another Vector, like ",a.createElement(t.code,null,"Vec<usize>")," etc."),"\n",a.createElement(t.p,null,"Now, as you might have noticed, Vectors are ",a.createElement(t.strong,null,"contiguous as well as growable"),", so how is that possible? The answer is concept of capacity and size."),"\n",a.createElement(t.h2,{id:"2-capacity-and-size",style:{position:"relative"}},a.createElement(t.a,{href:"#2-capacity-and-size","aria-label":"2 capacity and size permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. Capacity and Size"),"\n",a.createElement(t.p,null,"Actually, Rust vectors are allocated more memory than needed at the time of allocation. As soon as we need more memory, the complete array is copied to another location, and it is reallocated more memory."),"\n",a.createElement(t.p,null,"So, for example, you create a Vector of 5 instances, using ",a.createElement(t.code,null,"vec![0;5]"),". Rust will initially allocate capacity of 5 instances (",a.createElement(t.code,null,"i32")," in this case). Now, if you push any object, a new chunk of memory will be allocated for the vector.\nEach time the allocated space becomes full, ",a.createElement(t.strong,null,"Double memory space is allocated"),". So in above example, a vector with capacity to hold 10 instances will be created."),"\n",a.createElement(t.p,null,"However, the size or length of above vector will remain 6 itself, although the vector can now hold upto 10 instances. Let us see a code for better clarity."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},'fn main() {\n    // Create a vector of length 5, with all elements as 0\n    let mut vecky = vec![0; 5];\n\n    // Print Size and capacity\n    println!("Before adding element, size is {} and capacity is {}", vecky.len(), vecky.capacity());\n\n    // Push 1 more 0\n    vecky.push(0);\n\n    // Print Size and capacity\n    println!("After adding element, size is {} and capacity is {}", vecky.len(), vecky.capacity());\n}\n')),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Output")),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"Before adding element, size is 5 and capacity is 5 ",a.createElement("br"),"\nAfter adding element, size is 6 and capacity is 10"),"\n"),"\n",a.createElement(t.h2,{id:"3-creating-a-vector",style:{position:"relative"}},a.createElement(t.a,{href:"#3-creating-a-vector","aria-label":"3 creating a vector permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. Creating a vector"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Vector")," module ( std::vec::Vec ) is part of standard crate, and it is included in Rust ",a.createElement(t.strong,null,"Prelude"),", that means you don't have to include  std::vec::Vec explicitly for using vectors."),"\n",a.createElement(t.p,null,"So, let's get started by creating, that is initializing a vector in rust."),"\n",a.createElement(t.h3,{id:"31-vecnew",style:{position:"relative"}},a.createElement(t.a,{href:"#31-vecnew","aria-label":"31 vecnew permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.1 Vec::new()"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"Vec::new()")," method is used to initialize an empty vector, that is, with ",a.createElement(t.strong,null,"0 size and capacity.")," You don't have to specify the type of vector, because Rust will automatically determine the type, when you push any element into it."),"\n",a.createElement(t.p,null,"You should use it when you just want a vector, and don't have any information about it, like capacity, size etc."),"\n",a.createElement(t.p,null,"Here is sample initialization."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = Vec::new();\n")),"\n",a.createElement("br"),"\n",a.createElement(t.h3,{id:"32-vecwith_capacity",style:{position:"relative"}},a.createElement(t.a,{href:"#32-vecwith_capacity","aria-label":"32 vecwith_capacity permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.2 Vec::with_capacity()"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"Vec::with_capacity()")," method is the best method to initialize a vector when you have an idea how many elements will it contain and the type of elements stored, but don't know all the elements beforehand."),"\n",a.createElement(t.p,null,"This is my ",a.createElement(t.em,null,"personal preference")," to use in any competitive programming contest, because it is simply most efficient, because most of the time, the size of array and type of elements will already be provided in the testcase."),"\n",a.createElement(t.p,null,"So, the allocator doesn't have to reallocate again and again. Also, it doesn't initialize the elements, making it more efficient the ",a.createElement(t.code,null,"vec![]")," macro."),"\n",a.createElement(t.p,null,"Therefore, it is perhaps the most efficient way of creating dynamic vectors, when you have rough idea about how many elements will be stored in the vector and know the type of elements while initializing."),"\n",a.createElement(t.p,null,"Here is sample initialization, to initialize a vector of type ",a.createElement(t.code,null,"usize")," with maximum capacity to hold 5 numbers."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky: Vec<usize> = Vec::with_capacity(5);\n")),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Note :")," Capacity is not fixed, that is, if you insert more elements than initially declared capacity, it will still reallocate the space and copy the vector elements to the new location. It is handy and make this method more ",a.createElement(t.em,null,"flexible")),"\n",a.createElement("br"),"\n",a.createElement(t.h3,{id:"33-vec-macro",style:{position:"relative"}},a.createElement(t.a,{href:"#33-vec-macro","aria-label":"33 vec macro permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.3 vec![] Macro"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"vec![]")," is a macro for initialising a vector as well as inserting the elements into the vector. It is commonly used to create a vector when you want to initialise the vector with a given value."),"\n",a.createElement(t.p,null,"It can be done in two ways"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let vecky = vec![1, 2, 3, 4, 5];\n")),"\n",a.createElement(t.p,null,"This creates a vector [1, 2, 3, 4, 5] itself."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let vecky = vec![0;5]\n")),"\n",a.createElement(t.p,null,"This automates the initialising of vector. It takes a vector of size 5, and set all the values to 0. So, vector created is [0, 0, 0, 0, 0]."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Note :")," This method will create vector with exact capacity, like 5 for both of the above cases."),"\n",a.createElement(t.h3,{id:"34-to_vec-method",style:{position:"relative"}},a.createElement(t.a,{href:"#34-to_vec-method","aria-label":"34 to_vec method permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.4 to_vec() method"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"to_vec()")," method is a special method based on ",a.createElement(t.code,null,"collect")," for collecting objects to create a vector."),"\n",a.createElement(t.p,null,"It is useful when you want to ",a.createElement(t.strong,null,"convert an array or a slice of it")," to a vector.\nFor example"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let vec1 = [1, 2, 3, 4, 5];\nlet vecky = vec1[0..2].to_vec();\n")),"\n",a.createElement(t.h2,{id:"4-inserting-in-a-vector",style:{position:"relative"}},a.createElement(t.a,{href:"#4-inserting-in-a-vector","aria-label":"4 inserting in a vector permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4 Inserting in a vector"),"\n",a.createElement(t.p,null,"After we have created a vector, we may want to insert some elements to a vector. This can be done only if the vector is ",a.createElement(t.strong,null,"mutable"),". If the maximum capacity is reached, vector is reallocated the space at new location."),"\n",a.createElement(t.p,null,"We can insert into vector in mainly two ways."),"\n",a.createElement(t.h3,{id:"41-pushing-or-appending",style:{position:"relative"}},a.createElement(t.a,{href:"#41-pushing-or-appending","aria-label":"41 pushing or appending permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1 Pushing or appending"),"\n",a.createElement(t.p,null,"In the ",a.createElement(t.code,null,"push()")," method, we will simply add the element to the end of the vector. This is done in ",a.createElement(t.strong,null,"O(1)")," time complexity."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = vec![1, 2, 3, 4, 5];\nvecky.push(6);\n")),"\n",a.createElement(t.p,null,"In this, 6 is added to the end of the vector."),"\n",a.createElement(t.h3,{id:"42-inserting-anywhere",style:{position:"relative"}},a.createElement(t.a,{href:"#42-inserting-anywhere","aria-label":"42 inserting anywhere permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.2 Inserting anywhere"),"\n",a.createElement(t.p,null,"In the ",a.createElement(t.code,null,"insert()")," method inserts the given element at given index in the vector. All the elements to the right are shifted by 1 place to make space for the new element. Hence, this method take ",a.createElement(t.strong,null,"O( n )")," Time complexity."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = vec!['a', 'b', 'd', 'e'];\nvecky.insert(2, 'c');\n")),"\n",a.createElement(t.p,null,"The vector is ['a', 'b', 'c', 'd', 'e'] now"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Note :")),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,"This method uses 0 based indexing, that is first element is 0th element. Also, index is mentioned before the element, as you can see above."),"\n",a.createElement(t.li,null,"If given index > length of vector, this method will panic!"),"\n"),"\n",a.createElement(t.h2,{id:"5-accessing-elements-in-a-vector",style:{position:"relative"}},a.createElement(t.a,{href:"#5-accessing-elements-in-a-vector","aria-label":"5 accessing elements in a vector permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Accessing elements in a Vector"),"\n",a.createElement(t.p,null,"We should also be able to access the individual elements in the vector as well as the slice of it. We will discuss about it in this section."),"\n",a.createElement(t.h3,{id:"51-indexing-using-",style:{position:"relative"}},a.createElement(t.a,{href:"#51-indexing-using-","aria-label":"51 indexing using  permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.1 Indexing using []"),"\n",a.createElement(t.p,null,"We can access each element as well as the slice of a vector using indexing using square brackets or ",a.createElement(t.code,null,"[]"),"."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Note :")," We must ensure that the argument inside the [] must be usize to access the elements. This helps to ensure memory safety in rust."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"If only 1 argument is passed, it is matched with the given index, and the value at given index is returned."),"\n"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = vec!['a', 'b', 'c', 'd', 'e'];\nprintln!(\"{}\", vecky[2]);\n")),"\n",a.createElement(t.p,null,"We can also use slicing using square brackets, which we will discuss latter"),"\n",a.createElement(t.h3,{id:"52-get-method",style:{position:"relative"}},a.createElement(t.a,{href:"#52-get-method","aria-label":"52 get method permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.2 get() method"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"get()")," method is similar to using square brackets, except that it ",a.createElement(t.em,null,"does not panic on out of bound index"),".It returns the reference to the element or slice as ",a.createElement(t.code,null,"Option")," type. So, you can manually handle the not found case with ",a.createElement(t.code,null,"expect()")," or ",a.createElement(t.code,null,"match"),"."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = vec!['a', 'b', 'c', 'd', 'e'];\nprintln!(\"{}\", vecky.get(2).expect(\"Not found\"));\n")),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Note :")," This method returns an immutable reference by default. You can use ",a.createElement(t.code,null,"get_mut()")," to get mutable reference instead."),"\n",a.createElement(t.h2,{id:"6-removing-elements-from-a-vector",style:{position:"relative"}},a.createElement(t.a,{href:"#6-removing-elements-from-a-vector","aria-label":"6 removing elements from a vector permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6. Removing Elements from a vector"),"\n",a.createElement(t.h3,{id:"61-pop",style:{position:"relative"}},a.createElement(t.a,{href:"#61-pop","aria-label":"61 pop permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.1 pop()"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"pop()")," method is used to remove the last or the right most element from the vector. This method removes the right most element and also returns the removed element."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = vec!['a', 'b', 'c', 'd', 'e'];\nprintln!(\"{}\", vecky.pop().expect(\"Sorry, empty vector!\"));\n")),"\n",a.createElement(t.p,null,"This method returns ",a.createElement(t.code,null,"None")," if vector is empty, and takes ",a.createElement(t.strong,null,"O(1)")," Time complexity."),"\n",a.createElement(t.h3,{id:"62-remove",style:{position:"relative"}},a.createElement(t.a,{href:"#62-remove","aria-label":"62 remove permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.2 remove()"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"remove()")," method is used to remove an element from a given index from the vector. This method ",a.createElement(t.strong,null,"preserves the order")," by shifting all the elements on the right side by one place, and hence takes ",a.createElement(t.strong,null,"O(N)")," Time complexity."),"\n",a.createElement(t.p,null,"This method takes only 1 argument, that is index of the element to be removed."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = vec!['a', 'b', 'c', 'd', 'e'];\nvecky.remove(2);\n")),"\n",a.createElement(t.h3,{id:"63-swap_remove",style:{position:"relative"}},a.createElement(t.a,{href:"#63-swap_remove","aria-label":"63 swap_remove permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.3 swap_remove()"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"swap_remove()")," method is used to remove an element from the given index in the vector, when ",a.createElement(t.strong,null,"order of vector does not matter"),", by swapping the given index element with the last element, and removing the last element."),"\n",a.createElement(t.p,null,"This method is done in ",a.createElement(t.strong,null,"O(1)")," time complexity, and takes 1 argument, index of the element to be removed."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-rust"},"let mut vecky = vec!['a', 'b', 'c', 'd', 'e'];\nvecky.swap_remove(2);\nprintln!(\"{:?}\", vecky);\n")),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Output")),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"['a', 'b', 'e', 'd']"),"\n"),"\n",a.createElement(t.h2,{id:"conclusion",style:{position:"relative"}},a.createElement(t.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",a.createElement(t.p,null,"Vectors are array like contiguous and growable storage with a lot more functionalities.\nIn this article, we saw vectors and the basic built-in methods for creating a vector and inserting, accessing and removing an element from a vector in Rust."),"\n",a.createElement(t.p,null,"We will see more methods for vectors in the next article."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Thank You")),"\n","\n",a.createElement(c.H,{title:"Introduction to Vector basics - Rust Programming",description:"Vectors are array like contiguous and growable storage with a lot more functionalities. We will see vectors and the built-in methods for creating a vector and inserting, accessing and removing an element from a vector in Rust"}))}var i=function(e){void 0===e&&(e={});var t=Object.assign({},(0,l.ah)(),e.components).wrapper;return t?a.createElement(t,e,a.createElement(r,e)):r(e)};function o(e){return e.children}function s(e){return a.createElement(o,e,a.createElement(i,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-4-data-structures-vector-basics-mdx-d531e85f79aaebf1a9e3.js.map