"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3915],{69881:function(e,n,t){t.r(n),t.d(n,{default:function(){return o}});var l=t(27378),r=t(20951),a=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",em:"em",ol:"ol",li:"li",pre:"pre",code:"code",blockquote:"blockquote"},(0,r.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.h1,{id:"modular-multiplicative-inverse-in-rust",style:{position:"relative"}},l.createElement(n.a,{href:"#modular-multiplicative-inverse-in-rust","aria-label":"modular multiplicative inverse in rust permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Modular Multiplicative Inverse in Rust"),"\n",l.createElement(n.p,null,"And program in Rust to find it using Fermat's little theorem"),"\n",l.createElement(n.h2,{id:"what-is-modular-multiplicative-inverse",style:{position:"relative"}},l.createElement(n.a,{href:"#what-is-modular-multiplicative-inverse","aria-label":"what is modular multiplicative inverse permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"What is Modular Multiplicative Inverse"),"\n",l.createElement(n.p,null,"As we know that there is ",l.createElement(n.strong,null,"no divide operation in Modular Arithmetic"),". So, Modular Multiplicative Inverse is a number that ",l.createElement(n.em,null,"replaces")," divide function  in Modular Arithmetic.\nModular Multiplicative Inverse of ",l.createElement(n.strong,null,"n")," with respect to ",l.createElement(n.strong,null,"p")," is a natural number ",l.createElement(n.strong,null,"between 1 and p-1"),", let us say x, such that"),"\n",l.createElement("center",null," ",l.createElement("b",null," ( n × x )  mod p = 1 ")," "),"\n",l.createElement(n.p,null,"We can alternatively say that Modular Multiplicative Inverse is a number such that ",l.createElement(n.strong,null,"( n × x ) - 1 is divisible by p"),"."),"\n",l.createElement(n.p,null,"x can also be written as ",l.createElement(n.strong,null,"x = ( n",l.createElement("sup",null,"-1")," ) mod p")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"For Example :")," Modular Multiplicative Inverse of 23 with respect to 10 is 7. ( Because 23 × 7 = 161 and 161 % 10 = 1 )"),"\n",l.createElement("hr"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Note :")," The multiplicative inverse of  ",l.createElement(n.strong,null,"n")," with respect to ",l.createElement(n.strong,null,"p")," exists if and only if ",l.createElement(n.strong,null,"n and p are co prime numbers")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Proof :")," Let us suppose n = q × p + r , where q is quotient and r is remainder. So, if n is divisible by gcd, and p is divisible by gcd, then r must be divisible by gcd too. ( From Euclidean Algorithm )"),"\n",l.createElement(n.p,null,"Hence, if gcd > 1, then remainder must also be greater than 1."),"\n",l.createElement(n.h2,{id:"need-of-modular-multiplicative-inverse",style:{position:"relative"}},l.createElement(n.a,{href:"#need-of-modular-multiplicative-inverse","aria-label":"need of modular multiplicative inverse permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Need of Modular Multiplicative Inverse"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"For returning or printing fractional numbers in competitive programming. For example, we have to find ( p / q ) mod m. It is simply written as (p × q",l.createElement("sup",null,"-1"),") mod m or ( (p mod) ×  (q",l.createElement("sup",null,"-1"),") mod m ) mod m,\nwhere ",l.createElement(n.strong,null,"( q",l.createElement("sup",null,"-1")," ) mod m")," is Modular Multiplicative Inverse of q with respect to m."),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"To find Permutation and Combination of very large numbers. For example, we have to find ",l.createElement("sup",null,"100"),"P",l.createElement("sub",null,"50"),". We must first ",l.createElement(n.a,{href:"/number-theory/factorial-of-mutiple-numbers/"},"generate factorial array"),",\nthen compute Modular Multiplicative Inverse of 50! with respect to given number, and multiply it with 100! mod p, and then compute answer. We will discuss detailed method later."),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"In Cryptography, especially in RSA algorithm."),"\n"),"\n"),"\n",l.createElement(n.h2,{id:"naive-approach",style:{position:"relative"}},l.createElement(n.a,{href:"#naive-approach","aria-label":"naive approach permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Naive Approach"),"\n",l.createElement(n.p,null,"Simplest brute force solution can be to simply traverse all numbers from 1 to p-1, and return the number if ( n × x  ) % p = 1  or ( n × x ) - 1 is divisible by p."),"\n",l.createElement(n.p,null,"Function using this approach"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"fn mod_inverse (n:i128, p:i128) -> i128{\n    // Checks numbers from 1 to p-1\n    for x in 1..p {\n        if (n*x) % p == 1 {\n            return x;\n        }\n    }\n\n    // Returns 0 if no Modular Multiplicative Inverse exist\n    return 0;\n}\n")),"\n",l.createElement(n.p,null,"With Driver Code"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},'use std::io::stdin;\n\nfn take_int() -> i128 {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    input.trim().parse().unwrap()\n}\n\n// Magic starts here\n\nfn mod_inverse (n:i128, p:i128) -> i128{\n    // Checks numbers from 1 to p-1\n    for x in 1..p {\n        if (n*x) % p == 1 {\n            return x;\n        }\n    }\n\n    // Returns 0 if no Modular Multiplicative Inverse exist\n    return 0;\n}\n\n// Driver Code\n\npub fn main() {\n    let n = take_int();\n    let p = take_int();\n\n    println!("{}", mod_inverse(n, p));\n}\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Input")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"213 ",l.createElement("br"),"\n1000000007 ",l.createElement("br")),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"32863850"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Time Complexity : O( p )")," ",l.createElement("br"),"\n",l.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",l.createElement("br"),"\n",l.createElement(n.h2,{id:"efficient-fermats-little-theorem-solution",style:{position:"relative"}},l.createElement(n.a,{href:"#efficient-fermats-little-theorem-solution","aria-label":"efficient fermats little theorem solution permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Efficient Fermat's little theorem Solution"),"\n",l.createElement(n.p,null,"Generally, especially in competitive programming, we are given that the number, p, is prime number. So, we can easily find Modular Multiplicative Inverse using ",l.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Fermat%27s_little_theorem"},"Fermat's little theorem")),"\n",l.createElement(n.p,null,"From Fermat's little theorem,"),"\n",l.createElement("center",null," ",l.createElement("b",null," ( n",l.createElement("sup",null," p-1")," )  mod p = 1 ")," "),"\n",l.createElement(n.p,null,"Now, n",l.createElement("sup",null," p-1"),"  = n",l.createElement("sup",null," p-2")," × n. So, multiplying with n",l.createElement("sup",null,"-1")," both sides, we get."),"\n",l.createElement("center",null," ",l.createElement("b",null," ( n",l.createElement("sup",null," p-2")," )  mod p = ( n",l.createElement("sup",null," -1")," )  mod p ")," "),"\n",l.createElement(n.p,null,"We can easily calculate ( n",l.createElement("sup",null," p-2")," ) mod p using ",l.createElement(n.a,{href:"/number-theory/modular-exponentiation/"},"Modular Exponentiation in Rust"),"."),"\n",l.createElement(n.p,null,"Function using this approach is given below."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"// Function for Modular Exponentiation in Rust\n\n// Calculates (n^x) % p\nfn modular_exponent(mut n:i128 ,mut x:i128 , p:i128) -> i128{\n    let mut ans = 1;\n    if x<=0 { return 1; }\n    loop {\n        if x==1 { return (ans * n) % p; }\n        if x&1==0 {\n            n=( n * n ) % p;\n            x>>=1;\n            continue;\n        }\n        else {\n            ans = (ans*n) % p;\n            x-=1;\n        }\n    }\n}\n\n// Check GCD\nfn gcd(mut a:i128, mut b:i128) -> i128{\n    if a==b { return a; }\n    if b > a {\n        let temp = a;\n        a = b;\n        b = temp;\n    }\n    while b>0 {\n        let temp = a;\n        a = b;\n        b = temp%b;\n    }\n    return a;\n}\n\n// Magic starts here\nfn mod_inverse (n:i128, p:i128) -> i128{\n\n    // Returns 0 if no Modular Multiplicative Inverse exist\n    if p<=1 || gcd(n, p)>1 {\n        return 0;\n    }\n\n    // Return Modular Multiplicative Inverse, that is (n^(p-2)) mod p\n    // From Fermat's little theorem\n    return modular_exponent(n, p-2, p);\n}\n")),"\n",l.createElement(n.p,null,"Use the same driver code."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Input")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"213 ",l.createElement("br"),"\n1000000007 ",l.createElement("br")),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"32863850"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Time Complexity : O( log ",l.createElement("sub",null," 2 ")," p)")," ",l.createElement("br"),"\n",l.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",l.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},l.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",l.createElement(n.p,null,"Modular Multiplicative Inverse is a number that replaces the divide function in Modular Arithmetic."),"\n",l.createElement(n.p,null,"In this Article, we made a function to calculate Modular Multiplicative Inverse of a number with respect to a prime number using Fermat's little theorem in logarithmic time complexity."),"\n",l.createElement(n.p,null,"Code is pretty easier to understand, as compared to equivalent Extended Euclidean Algorithm."),"\n",l.createElement(n.p,null,"Here is function for easy access"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-rust"},"\n// Calculates (n^x) % p\nfn modular_exponent(mut n:i128 ,mut x:i128 , p:i128) -> i128{\n    let mut ans = 1;\n    if x<=0 { return 1; }\n    loop {\n        if x==1 { return (ans * n) % p; }\n        if x&1==0 { n=( n * n ) % p; x>>=1;continue; }\n        else { ans = (ans*n) % p; x-=1; }\n    }\n}\n// Find GCD\nfn gcd(mut a:i128, mut b:i128) -> i128{\n    if a==b { return a; }\n    if b > a { let temp = a;a = b;b = temp; }\n    while b>0 { let temp = a;a = b;b = temp%b; }\n    return a;\n}\n// Magic starts here\nfn mod_inverse (n:i128, p:i128) -> i128{\n    if p<=1 || gcd(n, p)>1 { return 0; }\n    return modular_exponent(n, p-2, p);\n}\n\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Thank You")),"\n","\n",l.createElement(a.H,{title:"Modular Multiplicative Inverse - Rust Programming",description:"Modular Multiplicative Inverse is a number that replaces the divide function in Modular Arithmetic. We will make a function to find Modular Multiplicative Inverse of a number in Rust, and optimize it to logarithmic time complexity using Fermat's little theorem"}))}var u=function(e){void 0===e&&(e={});var n=Object.assign({},(0,r.ah)(),e.components).wrapper;return n?l.createElement(n,e,l.createElement(i,e)):i(e)};function c(e){return e.children}function o(e){return l.createElement(c,e,l.createElement(u,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-2-number-theory-2-1-arithematic-operations-modular-inverse-mdx-39a5b148ecbc0f51d768.js.map