"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4200],{49204:function(e,n,t){t.r(n),t.d(n,{default:function(){return c}});var r=t(27378),l=t(20951),a=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",ol:"ol",li:"li",strong:"strong",pre:"pre",code:"code",blockquote:"blockquote"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h1,{id:"range-query-in-segment-tree",style:{position:"relative"}},r.createElement(n.a,{href:"#range-query-in-segment-tree","aria-label":"range query in segment tree permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Range Query in Segment Tree"),"\n",r.createElement(n.p,null,"and program to perform Range Query in a Segment Tree in Rust"),"\n",r.createElement(n.h2,{id:"introduction",style:{position:"relative"}},r.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",r.createElement(n.p,null,"I have already discussed the use cases as well as how to ",r.createElement(n.a,{href:"/array-algorithms/construct-segment-tree/"},"Construct the  Segment Tree in Rust Language"),".\nIf you have not already read that article, please visit that before, because this is continuation of that article."),"\n",r.createElement(n.p,null,"Here, we will actually perform Range Query on a segment tree to find output of a given subarray of an Array."),"\n",r.createElement(n.h2,{id:"approach",style:{position:"relative"}},r.createElement(n.a,{href:"#approach","aria-label":"approach permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approach"),"\n",r.createElement(n.p,null,"Now, if we look at our Segment Tree and Range Queries carefully, we can categorize them in one of 3 categories."),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"No Overlap :")," In this, the Range of our Query and Given Node does not contain any common element. So, we return identity element in this case."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Total Overlap :")," In this, all the elements of the ",r.createElement(n.strong,null,"given node")," are covered in the query. In this, we simply return the value of node."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Partial Overlap :")," In this, there exists some elements that are covered in a node, but not in the query. In this, we have to search in its children nodes recursively."),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"For example :")," If a node contains value from [2, 5] (inclusive)"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"No Overlap :")," Will contain range query such as [0, 1], [6, 7] etc."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Total Overlap :")," Will contain range query such [1, 7] , [2, 10] etc."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Partial Overlap :")," Will contain range query such [3, 7] , [2, 3] etc."),"\n"),"\n",r.createElement(n.h2,{id:"function",style:{position:"relative"}},r.createElement(n.a,{href:"#function","aria-label":"function permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn range_query(st:&Vec<usize>, nl:usize, nh:usize, ql:usize, qh:usize, pos : usize) -> usize{\n    //nl, nh == node low and node high respectively\n    // ql, qh == query low and query high respectively\n\n    // No Overlap, identity element in product is 1\n    if nh < ql || qh < nl {\n        return 1;\n    }\n\n    // Total overlap, return element at given node\n    if nh<= qh && nl>=ql {\n        return st[pos]\n    }\n\n    // Here, you can change operation as per requirement\n    // I am using product operator for reference\n    let mid = (h+l)/2;\n    return range_query(st, nl, mid, ql, qh, 2*pos + 1) * range_query(st, mid+1, nh, ql, qh, 2*pos + 1);\n}\n")),"\n",r.createElement(n.p,null,"With driver code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'\n\nfn range_query(st:&Vec<usize>, nl:usize, nh:usize, ql:usize, qh:usize, pos : usize) -> usize{\n    //nl, nh == node low and node high respectively\n    // ql, qh == query low and query high respectively\n\n    // Total overlap, return element at given node\n    if ql <= nl && qh>= nh {\n        return st[pos];\n    }\n\n    // No Overlap, identity element in product is 1\n    if nh < ql || qh < nl {\n        return 1;\n    }\n\n    // Partial Overlap, we search for both left and right children nodes\n    // You have to edit below as per required function.\n    let mid = (nh+nl)/2;\n    return range_query(st, nl, mid, ql, qh, pos*2 + 1) * range_query(st, mid+1, nh, ql, qh, pos*2 + 2);\n}\n\n// Construct the Segment Tree\n\nfn cs(n:usize) ->usize{\n    if n.count_ones() == 1 { return (n<<1)-1; }\n    let k = 1<<(64 - n.leading_zeros());\n    return (k<<1)-1;\n}\n\nfn cons_st(arr:&Vec<usize>) -> Vec<usize> {\n    let n = arr.len();\n    let s = cs(n);\n\n    // This is set as 1 by default for product only\n    let mut segment_tree = vec![1 as usize; s];\n    cons_st_util(arr, &mut segment_tree, 0, n-1, 0);\n    return segment_tree;\n}\n\nfn cons_st_util(arr:&Vec<usize>, tree:&mut Vec<usize>, l:usize, h:usize, pos:usize){\n    if h<l { return; }\n    if h == l { tree[pos] = arr[l];return; }\n    let mid = (h+l)/2;\n    cons_st_util(arr, tree, l, mid, pos*2+1);\n    cons_st_util(arr, tree, mid+1, h, pos*2+2);\n\n    // Here, you can change operation as per requirement\n    // I am using product operator for reference\n    tree[pos] = tree[pos*2+1]*tree[pos*2+2];\n}\n\nfn main() {\n    let arr = vec![1,2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let st = cons_st(&arr);\n\n    // We have to use arr.len() -1 as nh because inclusive range\n\n    // Prints product of first element\n    println!("{}", range_query(&st, 0, arr.len()-1, 0, 0, 0));\n\n    // Prints product of first 10 elements\n    println!("{}", range_query(&st, 0, arr.len()-1, 0, 9, 0));\n\n    // Prints product of elements 2 to 5 ( inclusive )\n    // So, the answer would be product of 3, 4, 5, 6\n    println!("{}", range_query(&st, 0, arr.len()-1, 2, 5, 0));\n\n    // Prints product of elements 1 to 7 (inclusive), arr[1] = 2 and arr[7] = 8\n    println!("{}", range_query(&st, 0, arr.len()-1, 1, 7, 0));\n}\n\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"1  ",r.createElement("br"),"\n3628800 ",r.createElement("br"),"\n360 ",r.createElement("br"),"\n40320 ",r.createElement("br")),"\n"),"\n",r.createElement(n.p,null,"If there are Q queries,"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( n + q*log(n) )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( n )")),"\n",r.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},r.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",r.createElement(n.p,null,"In this article, we saw how to perform range queries on a given segment tree in ",r.createElement(n.strong,null,"Logarithmic Time Complexity"),"."),"\n",r.createElement(n.p,null,"Now, you should be able to construct as well as perform Range Queries in a Segment Tree in Rust Language."),"\n",r.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"\nfn range_query(st:&Vec<usize>, nl:usize, nh:usize, ql:usize, qh:usize, pos : usize) -> usize{\n    if ql <= nl && qh>= nh { return st[pos]; }\n    if nh < ql || qh < nl { return 1; }\n    let mid = (nh+nl)/2;\n\n    // You have to edit below as per required function.\n    return range_query(st, nl, mid, ql, qh, pos*2 + 1) * range_query(st, mid+1, nh, ql, qh, pos*2 + 2);\n}\n")),"\n",r.createElement(n.p,null,"Segment Trees are especially useful for Min/Max and Or/Xor functions, especially when Update Queries are involved."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Thank You")),"\n","\n",r.createElement(a.H,{title:"Range Query in Segment Tree - Rust Programming",description:"Segment Trees are especially useful for Min/Max and Or/Xor functions, especially when Update Queries are involved. In this article, will see how to perform range queries on a given segment tree."}))}var s=function(e){void 0===e&&(e={});var n=Object.assign({},(0,l.ah)(),e.components).wrapper;return n?r.createElement(n,e,r.createElement(i,e)):i(e)};function o(e){return e.children}function c(e){return r.createElement(o,e,r.createElement(s,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-1-array-algorithms-query-segment-tree-mdx-b615a8cc967e1f54a66b.js.map