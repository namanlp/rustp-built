"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[670],{56831:function(e,n,t){t.r(n),t.d(n,{default:function(){return s}});var r=t(27378),a=t(20951),l=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",code:"code",strong:"strong",em:"em",pre:"pre",blockquote:"blockquote"},(0,a.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h1,{id:"modular-permutation",style:{position:"relative"}},r.createElement(n.a,{href:"#modular-permutation","aria-label":"modular permutation permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Modular Permutation"),"\n",r.createElement(n.p,null,"and program to find the Modular Permutation using Modular factorial Array and Modular Multiplicative inverse in Rust"),"\n",r.createElement(n.h2,{id:"introduction",style:{position:"relative"}},r.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",r.createElement(n.p,null,"In many problems, it becomes unfeasible to calculate Permutation using traditional data types like ",r.createElement(n.code,null,"i64")," or even ",r.createElement(n.code,null,"i128")," due to ",r.createElement(n.code,null,"overflow"),". The largest integer data type in rust, ",r.createElement(n.code,null,"u128")," can hold the number upto order of 10",r.createElement("sup",null,"38"),".\nBut Permutations grows pretty fast with n and r. For example, ",r.createElement(n.strong,null,r.createElement("sup",null,"100"),"P",r.createElement("sub",null,"100"))," is approximately is 9.33 × 10",r.createElement("sup",null,"157")),"\n",r.createElement(n.p,null,"So, it becomes unfeasible from competitive programming point of view to compute exact values using C / C++ / Rust etc.\nSo, in most programming contest, we have to find the answer modulo with respect to given number, generally ",r.createElement(n.strong,null,r.createElement("code",null,"10",r.createElement("sup",null,"9")," + 7 or 1000000007"))," is used because It is ",r.createElement(n.em,null,"safe prime number"),"."),"\n",r.createElement(n.p,null,"Hence, we will discuss how to find ",r.createElement(n.strong,null,"Modular Permutation")," or permutation of a large number with respect to a given number using ",r.createElement(n.a,{href:"/combinatorics/modular-factorial-array/"},"Modular factorial Array")," and ",r.createElement(n.a,{href:"/number-theory/modular-inverse/"},"Modular Multiplicative inverse")," in Rust."),"\n",r.createElement(n.h2,{id:"single-permutation",style:{position:"relative"}},r.createElement(n.a,{href:"#single-permutation","aria-label":"single permutation permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Single Permutation"),"\n",r.createElement(n.p,null,"When we have to find the value of 1 ",r.createElement("sup",null,"n"),"P",r.createElement("sub",null,"r"),", we can just find the modular permutation by using modular multiplication and multiplying numbers from ",r.createElement(n.code,null,"n-r+1")," to ",r.createElement(n.code,null,"n"),", inclusive."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Note:")," This would take linear time complexity for each permutation. So, this is efficient when there are fewer of queries ( When there are less than log(n) queries to be precise.)"),"\n",r.createElement(n.p,null,"Here is code for above implementation."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn modular_permutation(n: i128, r: i128, p:i128) -> i128{\n    // Take Answer to be 1\n    let mut ans = 1;\n\n    // nPr = n! / (n-r)! = (n-r+1) × (n-r+2) × .... × n\n    for i in (n-r+1)..(n+1) {\n        ans *= i;\n\n        // Division and Modulo are expensive for cpu\n        // So, we find modulo if answer is greater than or equal to p\n        // It can never become p though, else, answer will become 0\n        if ans>=p {\n            ans = ans%p;\n        }\n    }\n\n    return ans;\n}\n")),"\n",r.createElement(n.p,null,"With Driver Code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'\nfn modular_permutation(n: i128, r: i128, p:i128) -> i128{\n    // Take Answer to be 1\n    let mut ans = 1;\n\n    // nPr = n! / (n-r)! = (n-r+1) × (n-r+2) × .... × n\n    for i in (n-r+1)..(n+1) {\n        ans *= i;\n\n        // Division and Modulo are expensive for cpu\n        // So, we find modulo if answer is greater than or equal to p\n        // It can never become p though, else, answer will become 0\n        if ans>=p {\n            ans = ans%p;\n        }\n    }\n\n    return ans;\n}\n\n// Driver code\n\nuse std::io::stdin;\nfn take_int() -> i128 {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    return input.trim().parse().unwrap();\n}\n\npub fn main() {\n    // Take values of n, r and p\n    let n = take_int();\n    let r = take_int();\n    let p = take_int();\n    println!("{}", modular_permutation(n, r, p));\n}\n\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"100 ",r.createElement("br"),"\n50 ",r.createElement("br"),"\n1000000007"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"505671657"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( n )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",r.createElement(n.h2,{id:"efficient-approach",style:{position:"relative"}},r.createElement(n.a,{href:"#efficient-approach","aria-label":"efficient approach permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Efficient Approach"),"\n",r.createElement(n.p,null,"When we have to find large number of modular permutations, say 10",r.createElement("sup",null,"5")," or 10",r.createElement("sup",null,"6")," permutations and n can also range up to 10",r.createElement("sup",null,"5")," or 10",r.createElement("sup",null,"6"),", we can clearly see that above approach will result into\nTLE (Time Limit Exceeded) in Competitive Programming contests."),"\n",r.createElement(n.p,null,"So, we have to find Modular Permutation in Constant time for each test case."),"\n",r.createElement(n.p,null,"The idea is to first generate a ",r.createElement(n.a,{href:"/combinatorics/modular-factorial-array/"},"Modular Factorial Array")," and then find the number of permutations using equation"),"\n",r.createElement(n.p,null,r.createElement("sup",null,"n"),"P",r.createElement("sub",null,"r")," = n! / (n-r)!"),"\n",r.createElement(n.p,null,"Using Modular Arithmetic, this equation becomes"),"\n",r.createElement("center",null,r.createElement("b",null,"(",r.createElement("sup",null,"n")," P ",r.createElement("sub",null,"r"),") mod p = ((n!)  mod p * (n-r)! ",r.createElement("sup",null,"-1")," mod p) mod p ")," "),"\n",r.createElement(n.p,null,"To find the number of permutations."),"\n",r.createElement(n.p,null,"The implementation using this approach is."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn modular_permutation(n: usize, r: usize, p:usize, factorial_array:&Vec<usize>) -> usize{\n    return (factorial_array[n] * mod_inverse(factorial_array[n - r], p)) % p;\n}\n")),"\n",r.createElement(n.p,null,"With driver code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'\n\nfn modular_permutation(n: usize, r: usize, p:usize, factorial_array:&Vec<usize>) -> usize{\n    return (factorial_array[n] * mod_inverse(factorial_array[n - r], p)) % p;\n}\n\n// Driver code\n\nuse std::io::stdin;\nfn take_int() -> usize {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    return input.trim().parse().unwrap();\n}\n\n\nfn generate_factorial_array(max_number : usize, divisor : usize) -> Vec<usize>{\n    let mut factorial_array : Vec<usize> = vec![1; max_number+1];\n    for i in 2..(max_number + 1) {\n        factorial_array[i] = (factorial_array[i-1] * i) % divisor; }\n    return factorial_array;\n}\n\nfn modular_exponent(mut n:usize ,mut x:usize , p:usize) -> usize{\n    let mut ans = 1;\n    if x<=0 { return 1; }\n    loop { if x==1 { return (ans * n) % p; }\n        if x&1==0 { n=( n * n ) % p; x>>=1;continue; }\n        else { ans = (ans*n) % p; x-=1; }\n    }\n}\n\nfn mod_inverse (n:usize, p:usize) -> usize{\n    return modular_exponent(n, p-2, p);\n}\n\npub fn main() {\n    // Take values of n, r and p\n    let n = take_int();\n    let r = take_int();\n    let p = take_int();\n    // Contains factorial of all numbers from 1 to 10^6, modulo 10^9 + 7\n    let factorial_array = generate_factorial_array(1_000_000, 1_000_000_007);\n    println!("{}", modular_permutation(n, r, p, &factorial_array));\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"100 ",r.createElement("br"),"\n50 ",r.createElement("br"),"\n1000000007"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"505671657"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( nlog(n) )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( n )")),"\n",r.createElement("br"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Note:")," Although the time complexity is higher in this approach, it will be very less for higher number of queries. For example, if we have n queries of  ",r.createElement("sup",null,"n"),"P",r.createElement("sub",null,"r"),", the time taken by this approach will still be O( nlog(n) ),\nwhereas earlier approach will take O( n",r.createElement("sup",null,"2")," ) time. So, this is efficient only when there are ",r.createElement(n.strong,null,"higher number of queries"),"."),"\n",r.createElement(n.h2,{id:"summary",style:{position:"relative"}},r.createElement(n.a,{href:"#summary","aria-label":"summary permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Summary"),"\n",r.createElement(n.p,null,"Finding number of possible Permutations is one of the standard problems in Combinatorics. But as we know, it grows pretty fast, and it becomes necessary to compute modulo of number of Permutations in many problems."),"\n",r.createElement(n.p,null,"So, in this article, we saw how to find modular Permutation using Modular factorial Array and Modular Multiplicative inverse in Rust."),"\n",r.createElement(n.p,null,"Here is code for easy access"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn modular_exponent(mut n:usize ,mut x:usize , p:usize) -> usize{\n    let mut ans = 1;\n    if x<=0 { return 1; }\n    loop { if x==1 { return (ans * n) % p; }\n        if x&1==0 { n=( n * n ) % p; x>>=1;continue; }\n        else { ans = (ans*n) % p; x-=1; }\n    }\n}\n\nfn mod_inverse (n:usize, p:usize) -> usize{\n    return modular_exponent(n, p-2, p);\n}\n\n// Here is the function\nfn modular_permutation(n: usize, r: usize, p:usize, factorial_array:&Vec<usize>) -> usize{\n    return (factorial_array[n] * mod_inverse(factorial_array[n - r], p)) % p;\n}\n")),"\n","\n",r.createElement(l.H,{title:"Modular Permutation - Rust Programming",description:"In many problems, we may require to find number of possible permutations modulo with respect to a given number.So we will see how to find modular Permutation using Modular factorial Array and Modular Multiplicative inverse in Rust."}))}var o=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?r.createElement(n,e,r.createElement(i,e)):i(e)};function u(e){return e.children}function s(e){return r.createElement(u,e,r.createElement(o,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-3-combinatorics-modular-permutation-mdx-1f8613c86de33da3cb19.js.map