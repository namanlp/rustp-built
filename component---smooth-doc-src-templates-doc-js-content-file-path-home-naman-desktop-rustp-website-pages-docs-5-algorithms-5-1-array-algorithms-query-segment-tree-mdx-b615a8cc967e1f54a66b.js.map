{"version":3,"file":"component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-1-array-algorithms-query-segment-tree-mdx-b615a8cc967e1f54a66b.js","mappings":"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","sources":["webpack://website/./pages/docs/5 Algorithms/5.1 Array Algorithms/Query-Segment-Tree.mdx","webpack://website/../smooth-doc/src/templates/doc.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nimport {SEO} from \"smooth-doc/src/components/SEO\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    a: \"a\",\n    div: \"div\",\n    p: \"p\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h1, {\n    id: \"range-query-in-segment-tree\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#range-query-in-segment-tree\",\n    \"aria-label\": \"range query in segment tree permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Range Query in Segment Tree\"), \"\\n\", React.createElement(_components.p, null, \"and program to perform Range Query in a Segment Tree in Rust\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"introduction\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Introduction\"), \"\\n\", React.createElement(_components.p, null, \"I have already discussed the use cases as well as how to \", React.createElement(_components.a, {\n    href: \"/array-algorithms/construct-segment-tree/\"\n  }, \"Construct the  Segment Tree in Rust Language\"), \".\\nIf you have not already read that article, please visit that before, because this is continuation of that article.\"), \"\\n\", React.createElement(_components.p, null, \"Here, we will actually perform Range Query on a segment tree to find output of a given subarray of an Array.\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"approach\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#approach\",\n    \"aria-label\": \"approach permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Approach\"), \"\\n\", React.createElement(_components.p, null, \"Now, if we look at our Segment Tree and Range Queries carefully, we can categorize them in one of 3 categories.\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"No Overlap :\"), \" In this, the Range of our Query and Given Node does not contain any common element. So, we return identity element in this case.\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"Total Overlap :\"), \" In this, all the elements of the \", React.createElement(_components.strong, null, \"given node\"), \" are covered in the query. In this, we simply return the value of node.\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"Partial Overlap :\"), \" In this, there exists some elements that are covered in a node, but not in the query. In this, we have to search in its children nodes recursively.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"For example :\"), \" If a node contains value from [2, 5] (inclusive)\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"No Overlap :\"), \" Will contain range query such as [0, 1], [6, 7] etc.\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"Total Overlap :\"), \" Will contain range query such [1, 7] , [2, 10] etc.\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"Partial Overlap :\"), \" Will contain range query such [3, 7] , [2, 3] etc.\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"function\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#function\",\n    \"aria-label\": \"function permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Function\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn range_query(st:&Vec<usize>, nl:usize, nh:usize, ql:usize, qh:usize, pos : usize) -> usize{\\n    //nl, nh == node low and node high respectively\\n    // ql, qh == query low and query high respectively\\n\\n    // No Overlap, identity element in product is 1\\n    if nh < ql || qh < nl {\\n        return 1;\\n    }\\n\\n    // Total overlap, return element at given node\\n    if nh<= qh && nl>=ql {\\n        return st[pos]\\n    }\\n\\n    // Here, you can change operation as per requirement\\n    // I am using product operator for reference\\n    let mid = (h+l)/2;\\n    return range_query(st, nl, mid, ql, qh, 2*pos + 1) * range_query(st, mid+1, nh, ql, qh, 2*pos + 1);\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"With driver code\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"\\n\\nfn range_query(st:&Vec<usize>, nl:usize, nh:usize, ql:usize, qh:usize, pos : usize) -> usize{\\n    //nl, nh == node low and node high respectively\\n    // ql, qh == query low and query high respectively\\n\\n    // Total overlap, return element at given node\\n    if ql <= nl && qh>= nh {\\n        return st[pos];\\n    }\\n\\n    // No Overlap, identity element in product is 1\\n    if nh < ql || qh < nl {\\n        return 1;\\n    }\\n\\n    // Partial Overlap, we search for both left and right children nodes\\n    // You have to edit below as per required function.\\n    let mid = (nh+nl)/2;\\n    return range_query(st, nl, mid, ql, qh, pos*2 + 1) * range_query(st, mid+1, nh, ql, qh, pos*2 + 2);\\n}\\n\\n// Construct the Segment Tree\\n\\nfn cs(n:usize) ->usize{\\n    if n.count_ones() == 1 { return (n<<1)-1; }\\n    let k = 1<<(64 - n.leading_zeros());\\n    return (k<<1)-1;\\n}\\n\\nfn cons_st(arr:&Vec<usize>) -> Vec<usize> {\\n    let n = arr.len();\\n    let s = cs(n);\\n\\n    // This is set as 1 by default for product only\\n    let mut segment_tree = vec![1 as usize; s];\\n    cons_st_util(arr, &mut segment_tree, 0, n-1, 0);\\n    return segment_tree;\\n}\\n\\nfn cons_st_util(arr:&Vec<usize>, tree:&mut Vec<usize>, l:usize, h:usize, pos:usize){\\n    if h<l { return; }\\n    if h == l { tree[pos] = arr[l];return; }\\n    let mid = (h+l)/2;\\n    cons_st_util(arr, tree, l, mid, pos*2+1);\\n    cons_st_util(arr, tree, mid+1, h, pos*2+2);\\n\\n    // Here, you can change operation as per requirement\\n    // I am using product operator for reference\\n    tree[pos] = tree[pos*2+1]*tree[pos*2+2];\\n}\\n\\nfn main() {\\n    let arr = vec![1,2, 3, 4, 5, 6, 7, 8, 9, 10];\\n    let st = cons_st(&arr);\\n\\n    // We have to use arr.len() -1 as nh because inclusive range\\n\\n    // Prints product of first element\\n    println!(\\\"{}\\\", range_query(&st, 0, arr.len()-1, 0, 0, 0));\\n\\n    // Prints product of first 10 elements\\n    println!(\\\"{}\\\", range_query(&st, 0, arr.len()-1, 0, 9, 0));\\n\\n    // Prints product of elements 2 to 5 ( inclusive )\\n    // So, the answer would be product of 3, 4, 5, 6\\n    println!(\\\"{}\\\", range_query(&st, 0, arr.len()-1, 2, 5, 0));\\n\\n    // Prints product of elements 1 to 7 (inclusive), arr[1] = 2 and arr[7] = 8\\n    println!(\\\"{}\\\", range_query(&st, 0, arr.len()-1, 1, 7, 0));\\n}\\n\\n\")), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Output\")), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"1  \", React.createElement(\"br\"), \"\\n3628800 \", React.createElement(\"br\"), \"\\n360 \", React.createElement(\"br\"), \"\\n40320 \", React.createElement(\"br\")), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"If there are Q queries,\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Time Complexity : O( n + q*log(n) )\"), \" \", React.createElement(\"br\"), \"\\n\", React.createElement(_components.strong, null, \"Space Complexity : O( n )\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"conclusion\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Conclusion\"), \"\\n\", React.createElement(_components.p, null, \"In this article, we saw how to perform range queries on a given segment tree in \", React.createElement(_components.strong, null, \"Logarithmic Time Complexity\"), \".\"), \"\\n\", React.createElement(_components.p, null, \"Now, you should be able to construct as well as perform Range Queries in a Segment Tree in Rust Language.\"), \"\\n\", React.createElement(_components.p, null, \"Here is the optimized function for easy access\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"\\nfn range_query(st:&Vec<usize>, nl:usize, nh:usize, ql:usize, qh:usize, pos : usize) -> usize{\\n    if ql <= nl && qh>= nh { return st[pos]; }\\n    if nh < ql || qh < nl { return 1; }\\n    let mid = (nh+nl)/2;\\n\\n    // You have to edit below as per required function.\\n    return range_query(st, nl, mid, ql, qh, pos*2 + 1) * range_query(st, mid+1, nh, ql, qh, pos*2 + 2);\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"Segment Trees are especially useful for Min/Max and Or/Xor functions, especially when Update Queries are involved.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Thank You\")), \"\\n\", \"\\n\", React.createElement(SEO, {\n    title: \"Range Query in Segment Tree - Rust Programming\",\n    description: \"Segment Trees are especially useful for Min/Max and Or/Xor functions, especially when Update Queries are involved. In this article, will see how to perform range queries on a given segment tree.\"\n  }));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import React from \"react\";\nimport GATSBY_COMPILED_MDX from \"/home/naman/Desktop/rustp/website/pages/docs/5 Algorithms/5.1 Array Algorithms/Query-Segment-Tree.mdx\";\nimport {graphql} from 'gatsby';\nexport const pageQuery = graphql`\n  query DocPageQuery($id: String!) {\n    mdx(id: { eq: $id }) {\n      fields {\n        pageType\n        title\n        editLink\n      }\n      tableOfContents\n    }\n  }\n`;\nfunction DocTemplate({children}) {\n  return children;\n}\nDocTemplate\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(DocTemplate, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","h1","a","div","p","h2","ol","li","strong","pre","code","blockquote","_provideComponents","components","React","id","style","position","href","className","dangerouslySetInnerHTML","__html","SEO","title","description","MDXLayout","wrapper","DocTemplate","children","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}