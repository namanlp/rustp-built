"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[565],{63928:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var a=t(27378),o=t(20951),i=t(88957);function l(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",ul:"ul",li:"li",ol:"ol",h3:"h3",pre:"pre",code:"code",blockquote:"blockquote"},(0,o.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h1,{id:"coin-change-problem",style:{position:"relative"}},a.createElement(n.a,{href:"#coin-change-problem","aria-label":"coin change problem permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Coin Change Problem"),"\n",a.createElement(n.p,null,"and space optimized Dynamic Programming Solution using tabulation and memoization in Rust Language."),"\n",a.createElement(n.h2,{id:"introduction",style:{position:"relative"}},a.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",a.createElement(n.p,null,"Coin change is another classical Dynamic Programming problem."),"\n",a.createElement(n.p,null,"In this problem, you are given coins of various denomination, and each coin has infinite supply."),"\n",a.createElement(n.p,null,"You have to tell in how many ways you can form the given amount by using these coins any number of times."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"For Example :")," If coins are [1, 2, 3] and the amount is 4, there are ",a.createElement(n.strong,null,"4")," ways to form the amount using the coins, that is,"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"4 = 1 + 1 + 1 + 1"),"\n",a.createElement(n.li,null,"4 = 1 + 1 + 2"),"\n",a.createElement(n.li,null,"4 = 1+3"),"\n",a.createElement(n.li,null,"4 = 2 + 2"),"\n"),"\n",a.createElement(n.p,null,"Hence, the output should be ",a.createElement(n.strong,null,"4"),"."),"\n",a.createElement(n.p,null,"Similarly, if the coins are [1, 3] and the amount is 4, there are 2 ways only."),"\n",a.createElement(n.h2,{id:"recursive-solution",style:{position:"relative"}},a.createElement(n.a,{href:"#recursive-solution","aria-label":"recursive solution permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Recursive Solution"),"\n",a.createElement(n.p,null,"Recursive solution to this problem is pretty straightforward. At each step, you have 2 choices :"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Exclude the given coin :")," We can exclude the given coin and find the answer with the remaining coins. In this, we simply call recursion using same amount, but n-1 coins."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Include the given coin :")," We can include the coin and again call recursion by reducing amount, but on same number of coins, because we can include and exclude same coin again."),"\n"),"\n",a.createElement(n.p,null,"We have to take sum of both the cases."),"\n",a.createElement(n.p,null,"If amount is 0, there is only 1 way to form the amount, that is, by not using any coin."),"\n",a.createElement(n.p,null,"Also, if n is 0 and amount is not 0, we have to return 0, because there are no ways to make the amount in this way."),"\n",a.createElement(n.h3,{id:"function",style:{position:"relative"}},a.createElement(n.a,{href:"#function","aria-label":"function permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using above algorithm"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n\n    // If amount is 0, there is one way of making the change\n    // That is, do not take any coin\n    if amount == 0 { return 1; }\n\n    // If no coins left, return 0\n    if n==0 { return 0; }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        return coin_change(coins, amount, n-1);\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the coin_change of n items.\n    // Because we can include the coin again\n\n    // Return sum of both cases.\n    return coin_change(coins, amount, n-1)+coin_change(coins, amount-coins[n-1], n);\n}\n\n")),"\n",a.createElement(n.p,null,"With driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'\nfn coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n\n    // If amount is 0, there is one way of making the change\n    // That is, do not take any coin\n    if amount == 0 { return 1; }\n\n    // If no coins left, return 0\n    if n==0 { return 0; }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        return coin_change(coins, amount, n-1);\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the coin_change of n items.\n    // Because we can include the coin again\n\n    // Return sum of both cases.\n    return coin_change(coins, amount, n-1)+coin_change(coins, amount-coins[n-1], n);\n}\n\n\n// Driver Code\nuse std::io;\n\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    let coins = take_vector();\n    let amount = take_vector()[0];\n    println!("{}", coin_change(&coins, amount, coins.len()));\n}\n\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"1 2 3 ",a.createElement("br"),"\n4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( 2",a.createElement("sup",null,"n")," )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( n )")),"\n",a.createElement(n.p,null,"( Space complexity includes recursive stack space )"),"\n",a.createElement(n.h2,{id:"overlapping-sub-problems",style:{position:"relative"}},a.createElement(n.a,{href:"#overlapping-sub-problems","aria-label":"overlapping sub problems permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overlapping Sub-problems"),"\n",a.createElement(n.p,null,"If we have a look carefully on recursive approach, we computed multiple results many times."),"\n",a.createElement(n.p,null,"For example, if coins are [1, 2, 3, 6, 12] and amount is 24, the result for n = 2 and amount = 12 is calculated 4 times, and takes many recursions each time.\nThese are called overlapping sub-problems, because it is a sub-problem of actual problem and is overlapping in multiple recursions."),"\n",a.createElement(n.p,null,"To prevent this, we can store the output and each result will be calculated only once."),"\n",a.createElement(n.p,null,"In coin change problem, we can create a dp matrix, and store each value by coin index and amount. That is, if we consider first ",a.createElement(n.code,null,"i")," coins, the result will be stored at dp[i][amount]."),"\n",a.createElement(n.p,null,"This is called memoization or Top-down Dynamic Programming."),"\n",a.createElement(n.h2,{id:"memoization--top-down-dp--method",style:{position:"relative"}},a.createElement(n.a,{href:"#memoization--top-down-dp--method","aria-label":"memoization  top down dp  method permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memoization ( Top-down DP ) Method"),"\n",a.createElement(n.p,null,"In memoization method, we simply take a DP matrix, and store the computed result."),"\n",a.createElement(n.h3,{id:"algorithm",style:{position:"relative"}},a.createElement(n.a,{href:"#algorithm","aria-label":"algorithm permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"If the stored value for given number of coins and amount in DP matrix is not ",a.createElement(n.code,null,"None"),", we return the value."),"\n",a.createElement(n.li,null,"If the amount is 0, return 1 and if n is 0 and amount > 0, return 0."),"\n",a.createElement(n.li,null,"Else, use recursive logic to calculate the given value and store it in the DP matrix."),"\n"),"\n",a.createElement(n.h3,{id:"function-1",style:{position:"relative"}},a.createElement(n.a,{href:"#function-1","aria-label":"function 1 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using above algorithm"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"\nfn coin_change(coins:&Vec<usize>, amount : usize, n:usize, dp : &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    // If amount is 0, there is one way of making the change\n    // That is, do not take any coin\n    if amount == 0 { return 1; }\n\n    // If no coins left, return 0\n    if n==0 { return 0; }\n\n    // If already computed the value, return it\n    if dp[n][amount].is_some() {\n        return dp[n][amount].unwrap();\n    }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        dp[n][amount] = Option::from(coin_change(coins, amount, n-1, dp));\n        return dp[n][amount].unwrap();\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the coin_change of n items.\n    // Because we can include the coin again\n\n    // Return sum of both cases.\n    dp[n][amount] = Option::from( coin_change(coins, amount, n-1, dp)+coin_change(coins, amount-coins[n-1], n, dp));\n    return dp[n][amount].unwrap();\n}\n")),"\n",a.createElement(n.p,null,"With driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'\nfn coin_change(coins:&Vec<usize>, amount : usize, n:usize, dp : &mut Vec<Vec<Option<usize>>>) -> usize{\n\n    // If amount is 0, there is one way of making the change\n    // That is, do not take any coin\n    if amount == 0 { return 1; }\n\n    // If no coins left, return 0\n    if n==0 { return 0; }\n\n    // If already computed the value, return it\n    if dp[n][amount].is_some() {\n        return dp[n][amount].unwrap();\n    }\n\n    // If current coin is greater than amount, we can not include it\n    // Hence, compute recursively the coins of n-1\n    if coins[n-1] > amount {\n        dp[n][amount] = Option::from(coin_change(coins, amount, n-1, dp));\n        return dp[n][amount].unwrap();\n    }\n\n    // Now we can either exclude or include current coin\n    // If exclude, answer would be the coin_change of n-1 items\n    // If include, answer would be reduce the amount by denomination\n    // And calculate the coin_change of n items.\n    // Because we can include the coin again\n\n    // Return sum of both cases.\n    dp[n][amount] = Option::from( coin_change(coins, amount, n-1, dp)+coin_change(coins, amount-coins[n-1], n, dp));\n    return dp[n][amount].unwrap();\n}\n\n\n// Driver Code\nuse std::io;\n\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    let coins = take_vector();\n    let amount = take_vector()[0];\n\n    // Make a DP Matrix\n    // Initially set all the elements to None\n    let mut dp = vec![vec![Option::None; amount+1 ]; coins.len()+1];\n\n    println!("{}", coin_change(&coins, amount, coins.len(), &mut dp));\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"1 2 3 ",a.createElement("br"),"\n4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( n×amount )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( n×amount )")),"\n",a.createElement(n.h2,{id:"tabulation---bottom-up-dp---method",style:{position:"relative"}},a.createElement(n.a,{href:"#tabulation---bottom-up-dp---method","aria-label":"tabulation   bottom up dp   method permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tabulation  ( Bottom-up DP )  Method"),"\n",a.createElement(n.p,null,"Although time and space complexities of tabulation as well as memoization method are same, tabulation is much more efficient as there are a lot of expensive recursive calls in memoization."),"\n",a.createElement(n.p,null,"In tabulation method, we make the matrix, and fill it first on the basis of base condition, and then on the basis of previous row."),"\n",a.createElement(n.h3,{id:"algorithm-1",style:{position:"relative"}},a.createElement(n.a,{href:"#algorithm-1","aria-label":"algorithm 1 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Initially, set first row to 0, because if n == 0, we can not make amount, except when amount = 0.  Also, set first column as ",a.createElement(n.strong,null,"1"),", because if amount is 0, there is always 1 way to produce this."),"\n",a.createElement(n.li,null,"For all the amount for a given value of n, run below statement 3 and 4."),"\n",a.createElement(n.li,null,"Set the values before the coin value as copied from above row, because we can not include a coin if its value is less than the amount."),"\n",a.createElement(n.li,null,"Set the value of dp[i][amount] as dp[i][amount-coins[n-1]] + dp[i-1][amount] for inclusion and exclusion of the given coin respectively."),"\n",a.createElement(n.li,null,"Return the dp[n][amount] as the final answer."),"\n"),"\n",a.createElement(n.h3,{id:"function-2",style:{position:"relative"}},a.createElement(n.a,{href:"#function-2","aria-label":"function 2 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using above algorithm"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn coin_change(coins:&Vec<usize>, amount : usize, n:usize, dp : &mut Vec<Vec<usize>>) -> usize{\n\n    // Set first column as 1\n    for i in 0..n+1 { dp[i][0] = 1; }\n\n    // Set the first row as 0\n    for i in 1..amount+1 { dp[0][i] = 0; }\n\n    // Run loop for all the i from 1 to n\n    for i in 1..n+1 {\n        // Run loop for each amount below coins[n-1], set above row\n        for j in 1..coins[i-1]{\n            dp[i][j] = dp[i-1][j];\n        }\n\n        // Now, for larger amount, we can both include and exclude.\n        // So, we take sum of both cases\n        for j in coins[i-1]..amount+1 {\n            dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j];\n        }\n    }\n\n    // Return The answer\n    dp[n][amount]\n}\n")),"\n",a.createElement(n.p,null,"With Driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'\nfn coin_change(coins:&Vec<usize>, amount : usize, n:usize, dp : &mut Vec<Vec<usize>>) -> usize{\n\n    // Set first column as 1\n    for i in 0..n+1 { dp[i][0] = 1; }\n\n    // Set the first row as 0\n    for i in 1..amount+1 { dp[0][i] = 0; }\n\n    // Run loop for all the i from 1 to n\n    for i in 1..n+1 {\n        // Run loop for each amount below coins[n-1], set above row\n        for j in 1..coins[i-1]{\n            dp[i][j] = dp[i-1][j];\n        }\n\n        // Now, for larger amount, we can both include and exclude.\n        // So, we take sum of both cases\n        for j in coins[i-1]..amount+1 {\n            dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j];\n        }\n    }\n\n    // Return The answer\n    dp[n][amount]\n}\n\n\n// Driver Code\nuse std::io;\n\nfn take_vector() -> Vec<usize> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let arr: Vec<usize> = input.trim().split_whitespace()\n        .map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\nfn main() {\n    let coins = take_vector();\n    let amount = take_vector()[0];\n\n    // Make a DP Matrix\n    // Initially set all the elements to None\n    let mut dp = vec![vec![0 as usize; amount+1 ]; coins.len()+1];\n\n    println!("{}", coin_change(&coins, amount, coins.len(), &mut dp));\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"1 2 3 ",a.createElement("br"),"\n4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( n×amount )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( n×amount )")),"\n",a.createElement(n.h2,{id:"space-optimized-tabulation-method",style:{position:"relative"}},a.createElement(n.a,{href:"#space-optimized-tabulation-method","aria-label":"space optimized tabulation method permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Space Optimized Tabulation Method"),"\n",a.createElement(n.p,null,"If we observe the above tabulation method carefully, we find that for calculating coin change for a given amount and number of coins, only ",a.createElement(n.strong,null,"current and previous row")," is required."),"\n",a.createElement(n.p,null,"In the above algorithm, step 1 is base case or initialization step, and do not require any other row."),"\n",a.createElement(n.p,null,"Step 3 and Step 4 requires only previous and current row."),"\n",a.createElement(n.p,null,"Hence, we can optimize our space complexity, by storing only the previous row instead of the whole matrix."),"\n",a.createElement(n.h3,{id:"function-3",style:{position:"relative"}},a.createElement(n.a,{href:"#function-3","aria-label":"function 3 permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",a.createElement(n.p,null,"Here is the function using space optimization of tabulation method."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n\n    let mut prev = vec![0; amount+1];\n    let mut current = vec![0; amount+1];\n\n    // Set first column to 1\n    prev[0] = 1;\n    current[0] = 1;\n\n    // Run loop for all the i from 1 to n\n    for i in 1..n+1 {\n        // Run loop for each amount below coins[n-1], set above row\n        for j in 1..coins[i-1]{\n            current[j] = prev[j];\n        }\n\n        // Now, for larger amount, we can both include and exclude.\n        // So, we take sum of both cases\n        for j in coins[i-1]..amount+1 {\n            current[j] = current[j-coins[i-1]] + prev[j];\n        }\n\n        // Copy the elements of current to previous\n        for j in 0..amount+1 {\n            prev[j] = current[j];\n        }\n    }\n\n    // Return last element of current array\n    current[amount]\n}\n")),"\n",a.createElement(n.p,null,"Use the same driver code except removing the dp matrix input."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"1 2 3 ",a.createElement("br"),"\n4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"4"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( n×amount )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( amount )")),"\n",a.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},a.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",a.createElement(n.p,null,"Coin Change Problem is a classical Dynamic Programming problem. In this problem, you have to tell in how many ways you can form the given amount by using given coins any number of times."),"\n",a.createElement(n.p,null,"In this article, we saw how to solve the coin change problem, first using recursion and then using Dynamic Programming, memoization as well as tabulation method, and latter the space optimized tabulation method in Rust Language."),"\n",a.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{\n    let mut prev = vec![0; amount+1];\n    let mut current = vec![0; amount+1];\n    prev[0] = 1; current[0] = 1;\n    for i in 1..n+1 {\n        for j in 1..coins[i-1]{ current[j] = prev[j]; }\n        for j in coins[i-1]..amount+1 { current[j] = current[j-coins[i-1]] + prev[j]; }\n        for j in 0..amount+1 { prev[j] = current[j]; }\n    }\n    current[amount]\n}\n")),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Thank You")),"\n","\n",a.createElement(i.H,{title:"Coin Change Problem with Space Optimization ( DP ) - Dynamic Programming - Rust Programming",description:"Tell unique ways to form the amount using given coins. We will see recursive, memoization, tabulation and space optimized DP solution in Rust Language."}))}var r=function(e){void 0===e&&(e={});var n=Object.assign({},(0,o.ah)(),e.components).wrapper;return n?a.createElement(n,e,a.createElement(l,e)):l(e)};function c(e){return e.children}function u(e){return a.createElement(c,e,a.createElement(r,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-2-dynamic-programming-coin-change-mdx-a2f95c539f66a016c49a.js.map