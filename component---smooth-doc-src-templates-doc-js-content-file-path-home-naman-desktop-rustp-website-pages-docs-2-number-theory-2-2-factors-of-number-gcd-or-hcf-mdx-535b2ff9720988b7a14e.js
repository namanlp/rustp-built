"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[12],{14303:function(e,n,t){t.r(n),t.d(n,{default:function(){return s}});var a=t(27378),l=t(20951),r=t.p+"static/gcd-or-hcf-b945f307e5504d3cd7673657189458ea.webp",i=t(88957);function c(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",pre:"pre",code:"code",blockquote:"blockquote",ul:"ul",li:"li"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h1,{id:"gcd-or-hcf-of-two-numbers",style:{position:"relative"}},a.createElement(n.a,{href:"#gcd-or-hcf-of-two-numbers","aria-label":"gcd or hcf of two numbers permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"GCD or HCF of two numbers"),"\n",a.createElement(n.p,null,"and program in Rust to calculate it using Euclidean algorithm."),"\n",a.createElement(n.h2,{id:"what-is-gcd-or-hcf",style:{position:"relative"}},a.createElement(n.a,{href:"#what-is-gcd-or-hcf","aria-label":"what is gcd or hcf permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"What is GCD or HCF"),"\n",a.createElement(n.p,null,"Greatest Common Divisor ( GCD ) or Highest Common Factor ( HCF ) of two natural numbers is the largest natural number that divides both numbers."),"\n",a.createElement(n.p,null,"We can also say it is the largest natural number that is factor of both numbers."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"For Example :")," GCD of 100 and 75 is 25"),"\n","\n",a.createElement("div",{style:{textAlign:"center"}},a.createElement("img",{src:r,width:"100%",alt:"GCD of 150 and 210 is 30"})),"\n",a.createElement(n.h2,{id:"naive-approach",style:{position:"relative"}},a.createElement(n.a,{href:"#naive-approach","aria-label":"naive approach permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Naive Approach"),"\n",a.createElement(n.p,null,"Let us suppose we have to find gcd or hcf of 2 numbers, a and b."),"\n",a.createElement(n.p,null,"Naive or brute force approach is to traverse all the numbers from 1 to min(a, b), and check if the number divides both numbers. Function using this approach is"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn gcd(a:i128, b:i128) -> i128{\n    // Initialize ans, or answer and limit\n    let mut ans:i128 = 1;\n    let limit = min(a,b);\n\n    // Loop from 2 to limit, both inclusive\n    for i in 2..(limit+1) {\n        // Check if both a and b are divisible\n        if a%i == 0 && b%i == 0 {\n            ans = i;\n        }\n    }\n    return ans;\n}\n")),"\n",a.createElement(n.p,null,"Program With driver code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'use std::cmp::min;\nuse std::io::stdin;\n\n// Read Input\n\nfn take_vector() -> Vec<i128> {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    let arr: Vec<i128> = input.trim().\n        split_whitespace().map(|x| x.parse().unwrap()).collect();\n    return arr;\n}\n\n// Magic Starts here\n\nfn gcd(a:i128, b:i128) -> i128{\n    // Initialize ans, or answer and limit\n    let mut ans:i128 = 1;\n    let limit = min(a,b);\n\n    // Loop from 2 to limit, both inclusive\n    for i in 2..(limit+1) {\n        // Check if both a and b are divisible\n        if a%i == 0 && b%i == 0 {\n            ans = i;\n        }\n    }\n    return ans;\n}\n\n// Driver Code\n\npub fn main() {\n    let numbers = take_vector();\n    println!("{}", gcd(numbers[0], numbers[1]));\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"210 150"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"30"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( min (a, b) )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",a.createElement(n.h2,{id:"efficient-euclidean-algorithm",style:{position:"relative"}},a.createElement(n.a,{href:"#efficient-euclidean-algorithm","aria-label":"efficient euclidean algorithm permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Efficient Euclidean algorithm"),"\n",a.createElement(n.p,null,"We can find the gcd of 2 numbers using Euclidean algorithm in ",a.createElement(n.strong,null,"logarithmic time complexity")),"\n",a.createElement(n.p,null,"Refer ",a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Euclidean_algorithm"},"Wikipedia")),"\n",a.createElement(n.p,null,"In simple words, let us suppose that we have to find gcd of 2 distinct numbers, a and b, such that a > b."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"If a%b == 0, then obviously b is the gcd."),"\n",a.createElement(n.li,null,"If a%b != 0, then gcd must divide both b and a%b ( from Euclidean algorithm or even general observation ). So, we can now find gcd of b and a%b, which will be the answer."),"\n"),"\n",a.createElement(n.p,null,"Also, clearly, b > a%b."),"\n",a.createElement(n.p,null,"Function using this approach is"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn gcd(mut a:i128, mut b:i128) -> i128{\n    // If equal, return any of them\n    if a==b {\n        return a;\n    }\n\n    // Swap a with b, if b is greater than a\n    if b > a {\n        let temp = a;\n        a = b;\n        b = temp;\n    }\n\n    while b>0 {\n        // This is the trickiest part\n        // We swap a with b, and b with a%b, till b becomes 0\n        let temp = a;\n        a = b;\n        b = temp%b;\n    }\n\n    // Now, a%b = 0, hence return it\n    return a;\n}\n")),"\n",a.createElement(n.p,null,"Use the same driver code."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Input")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"210 150"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Output")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"30"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Time Complexity : O( log(min (a, b)) )")," ",a.createElement("br"),"\n",a.createElement(n.strong,null,"Space Complexity : O( 1 )")),"\n",a.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},a.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",a.createElement(n.p,null,"Greatest Common Divisor ( GCD ) or Highest Common Factor ( HCF ) of two natural numbers is the largest natural number that divides both numbers. In this article, we made a program to compute GCD or HCF in ",a.createElement(n.strong,null,"Logarithmic Time Complexity")," using Euclidean algorithm."),"\n",a.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},"fn gcd(mut a:i128, mut b:i128) -> i128{\n    if a==b { return a; }\n    if b > a {\n        let temp = a;\n        a = b;\n        b = temp;\n    }\n    while b>0 {\n        let temp = a;\n        a = b;\n        b = temp%b;\n    }\n    return a;\n}\n")),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Thank You")),"\n","\n",a.createElement(i.H,{title:"GCD or Greatest Common Divisor using Euclidean algorithm - Rust Programming",description:"Greatest Common Divisor or Highest Common Factor of two natural numbers is the largest natural number that divides both numbers. We will make function to find GCD or HCF of two numbers and optimize it to logarithmic time complexity using Euclidean algorithm."}))}var o=function(e){void 0===e&&(e={});var n=Object.assign({},(0,l.ah)(),e.components).wrapper;return n?a.createElement(n,e,a.createElement(c,e)):c(e)};function m(e){return e.children}function s(e){return a.createElement(m,e,a.createElement(o,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-2-number-theory-2-2-factors-of-number-gcd-or-hcf-mdx-535b2ff9720988b7a14e.js.map