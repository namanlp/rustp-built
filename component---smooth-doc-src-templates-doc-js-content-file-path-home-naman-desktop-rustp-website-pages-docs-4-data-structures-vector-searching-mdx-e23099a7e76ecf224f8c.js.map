{"version":3,"file":"component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-4-data-structures-vector-searching-mdx-e23099a7e76ecf224f8c.js","mappings":"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","sources":["webpack://website/./pages/docs/4 Data Structures/vector-searching.mdx","webpack://website/../smooth-doc/src/templates/doc.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nimport {SEO} from \"smooth-doc/src/components/SEO\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    a: \"a\",\n    div: \"div\",\n    p: \"p\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h1, {\n    id: \"searching-in-a-vector\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#searching-in-a-vector\",\n    \"aria-label\": \"searching in a vector permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Searching in a vector\"), \"\\n\", React.createElement(_components.p, null, \"and program for linear and binary search in a vector Rust\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"introduction\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Introduction\"), \"\\n\", React.createElement(_components.p, null, \"Searching is finding the index of an element in a collection of elements. Here, in this article, we will discuss how to search for a given element in a vector.\"), \"\\n\", React.createElement(_components.p, null, \"We can search for an element in a vector ar an array in 2 possible ways\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"Linear Search :\"), \" In this, we traverse through whole vector till the element is found. Hence, it takes \", React.createElement(_components.strong, null, \"O( n )\"), \" time complexity.\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"Binary Search :\"), \" In this, we only check mid-points instead of checking the whole vector. Hence, it takes only \", React.createElement(_components.strong, null, \"O( log(n) )\"), \" time complexity. Vector must be sorted for Binary Search.\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"linear-search\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#linear-search\",\n    \"aria-label\": \"linear search permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Linear Search\"), \"\\n\", React.createElement(_components.p, null, \"In the Linear Search, we traverse the whole vector, and check if the given element is equal to key. If the element is found, its index is returned.\"), \"\\n\", React.createElement(_components.p, null, \"As it traverses the whole array, it takes \", React.createElement(_components.strong, null, \"O( n )\"), \" time complexity.\"), \"\\n\", React.createElement(_components.p, null, \"Also, \", React.createElement(_components.strong, null, \"order of array does not matter\"), \" for linear search. It is very simple to implement. Here is a simple function demonstrating Linear Search\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn search(vecky:&Vec<usize>, key:usize) -> usize{\\n    for i in 0..vecky.len() {\\n        if vecky[i] == key {\\n            return i;\\n        }\\n    }\\n\\n    // If element is not found\\n    return vecky.len();\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"Program With driver code\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn search(vecky:&Vec<usize>, key:usize) -> usize{\\n    for i in 0..vecky.len() {\\n        if vecky[i] == key {\\n            return i;\\n        }\\n    }\\n\\n    // If element is not found\\n    return vecky.len();\\n}\\n\\n// Driver code\\n\\nfn main() {\\n    let vecky = vec![0, 1, 2, 3, 4, 5];\\n    println!(\\\"{}\\\", search(&vecky, 4) );\\n    println!(\\\"{}\\\", search(&vecky, 100) );\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Output\")), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"4 \", React.createElement(\"br\"), \"\\n6\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Time Complexity : O( n )\"), \" \", React.createElement(\"br\"), \"\\n\", React.createElement(_components.strong, null, \"Space Complexity : O( 1 )\")), \"\\n\", React.createElement(_components.p, null, \"The standard crate in Rust only has \", React.createElement(_components.code, null, \"binary_search()\"), \" and \", React.createElement(_components.code, null, \"contains()\"), \" function. So, you will have to make your own search function for Linear Search, as above\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"binary-search\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#binary-search\",\n    \"aria-label\": \"binary search permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Binary Search\"), \"\\n\", React.createElement(_components.p, null, \"In the Binary Search, we only check the midpoints of a \", React.createElement(_components.strong, null, \"sorted list\"), \". Each time, we have to search only in half of the list. Hence, its complexity is \", React.createElement(_components.strong, null, \"O( log(n) )\"), \".\"), \"\\n\", React.createElement(_components.p, null, \"Also, the vector \", React.createElement(_components.strong, null, \"must be sorted\"), \" for Binary search.\"), \"\\n\", React.createElement(_components.p, null, \"Here is the Algorithm\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"Calculate the mid-point of the \", React.createElement(_components.strong, null, \"sorted\"), \" vector.\"), \"\\n\", React.createElement(_components.li, null, \"If the element is equal to the mid-point, return the index of the mid-point.\"), \"\\n\", React.createElement(_components.li, null, \"If the Element is greater than the mid-point, search for the element in the slice containing the larger values.\"), \"\\n\", React.createElement(_components.li, null, \"If the element is less than the mid-point, search the elements in slice containing smaller values than the mid-point.\"), \"\\n\", React.createElement(_components.li, null, \"Go back to step 2, till we have no elements left in the slice.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Note :\"), \" If we observe carefully, each time if the element is not found, we have to find for the element in only the half of the vector. So, it takes only \", React.createElement(_components.strong, null, \"O ( log(n) )\"), \" for finding any element.\"), \"\\n\", React.createElement(_components.p, null, \"Here is the function for Binary Search in Rust\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn binary_search(vecky:&Vec<usize>, key:usize) -> usize{\\n    let mut low = 0;\\n    let mut high = vecky.len()-1;\\n\\n    while low <= high {\\n        let mid = low + (high - low) / 2;\\n\\n        // If key is middle element, return it\\n        if vecky[mid] == key {\\n            return mid;\\n        }\\n\\n        // If key is greater than middle element, we ignore left half\\n        if vecky[mid] < key {\\n            low = mid + 1;\\n        }\\n\\n        // If key is less than middle element, we ignore right half\\n        else{\\n            high = mid - 1;\\n        }\\n    }\\n    // If the element is not found\\n    return vecky.len();\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"Use the same driver code.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Output\")), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"4 \", React.createElement(\"br\"), \"\\n6\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Time Complexity : O( log(n) )\"), \" \", React.createElement(\"br\"), \"\\n\", React.createElement(_components.strong, null, \"Space Complexity : O( 1 )\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"binary_search-function\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#binary_search-function\",\n    \"aria-label\": \"binary_search function permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"binary_search() function\"), \"\\n\", React.createElement(_components.p, null, \"Rust already has \", React.createElement(_components.strong, null, React.createElement(_components.code, null, \"binary_search()\")), \" function built into it. It is already there in \", React.createElement(_components.code, null, \"std::vec::Vec\"), \" and hence, included in prelude. So, you don't even have to import it explicitly.\"), \"\\n\", React.createElement(_components.p, null, \"For example,\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn main() {\\n    let vecky = vec![0, 1, 2, 3, 4, 5];\\n    println!(\\\"{}\\\", vecky.binary_search(&4).expect(\\\"Not found\\\") );\\n    println!(\\\"{}\\\", vecky.binary_search( &100).expect(\\\"Not Found\\\") );\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Output\")), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"4 \", React.createElement(\"br\"), \"\\nthread 'main' panicked at 'Not Found: 6'\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"Hence, you can easily use \", React.createElement(_components.code, null, \"binary_search()\"), \" function on any vector or  a slice of vector in Rust.\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"conclusion\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Conclusion\"), \"\\n\", React.createElement(_components.p, null, \"Searching is an important operation in a Vector. In this article, we discussed Linear Search as well as Binary Search and saw their programs and also how to use built-in function to perform Search in Rust.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Thank You\")), \"\\n\", \"\\n\", React.createElement(SEO, {\n    title: \"Searching in a Vector - Rust Programming\",\n    description: \"Searching is an important operation in a Vector. In this article, we will discuss Linear Search as well as Binary Search and see their programs and also how to use built-in function to perform Search in Rust\"\n  }));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import React from \"react\";\nimport GATSBY_COMPILED_MDX from \"/home/naman/Desktop/rustp/website/pages/docs/4 Data Structures/vector-searching.mdx\";\nimport {graphql} from 'gatsby';\nexport const pageQuery = graphql`\n  query DocPageQuery($id: String!) {\n    mdx(id: { eq: $id }) {\n      fields {\n        pageType\n        title\n        editLink\n      }\n      tableOfContents\n    }\n  }\n`;\nfunction DocTemplate({children}) {\n  return children;\n}\nDocTemplate\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(DocTemplate, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","h1","a","div","p","h2","ol","li","strong","pre","code","blockquote","_provideComponents","components","React","id","style","position","href","className","dangerouslySetInnerHTML","__html","SEO","title","description","MDXLayout","wrapper","DocTemplate","children","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}