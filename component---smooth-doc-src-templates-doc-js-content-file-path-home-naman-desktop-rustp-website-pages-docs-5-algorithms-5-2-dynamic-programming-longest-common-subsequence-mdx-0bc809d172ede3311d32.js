"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6477],{82474:function(e,n,t){t.r(n),t.d(n,{default:function(){return c}});var r=t(27378),l=t(20951),a=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",code:"code",h3:"h3",ol:"ol",li:"li",pre:"pre",blockquote:"blockquote"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h1,{id:"longest-common-subsequence--lcs-",style:{position:"relative"}},r.createElement(n.a,{href:"#longest-common-subsequence--lcs-","aria-label":"longest common subsequence  lcs  permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Longest Common Subsequence ( LCS )"),"\n",r.createElement(n.p,null,"and program to find Longest Common Subsequence using Dynamic Programming in Rust."),"\n",r.createElement(n.h2,{id:"introduction",style:{position:"relative"}},r.createElement(n.a,{href:"#introduction","aria-label":"introduction permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction"),"\n",r.createElement(n.p,null,"Longest Common Subsequence is a classical Dynamic Programming problem, in which we have to find the length of longest common subsequence of the given strings."),"\n",r.createElement(n.p,null,"Subsequence of a string is defined as a string, that is formed by removing 1 or more elements from the original string."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"For Example :"),' For the string "RUSTP", the strings "RUST", "RP", "R", "UP" etc. are subsequences, but the strings "PT", "Z", "TS"'),"\n",r.createElement(n.p,null,"So, we are given 2 strings, say ",r.createElement(n.code,null,"string1")," and ",r.createElement(n.code,null,"string2")," we have to find length of Longest Common Subsequence."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"For Example :")," If ",r.createElement(n.code,null,"string1"),' = "abcdef" and ',r.createElement(n.code,null,"string2"),' = "acfbde", the longest common subsequence is "abde", so answer is 4.'),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Note :")," In Rust Language, the ",r.createElement(n.code,null,"String")," is UTF-8 encoded by default, hence, indexing is not possible in ",r.createElement(n.code,null,"String")," type. Hence, we use ",r.createElement(n.strong,null,r.createElement(n.code,null,"Vec<char>"))," instead."),"\n",r.createElement(n.h2,{id:"recursive-solution",style:{position:"relative"}},r.createElement(n.a,{href:"#recursive-solution","aria-label":"recursive solution permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Recursive Solution"),"\n",r.createElement(n.p,null,"Before jumping into dynamic programming solution, we will first have a look at recursive solution."),"\n",r.createElement(n.h3,{id:"algorithm",style:{position:"relative"}},r.createElement(n.a,{href:"#algorithm","aria-label":"algorithm permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",r.createElement(n.p,null,"In recursive solution, we apply the given algorithm."),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"If the last character of both the string is same, we must include it to our solution and recursively find the LCS of remaining string."),"\n",r.createElement(n.li,null,"Else, we first check by removing last character from first string and then the last character from second string, and return the maximum of both the cases."),"\n",r.createElement(n.li,null,"Repeat steps 1 and 2 till either of string is empty."),"\n"),"\n",r.createElement(n.h3,{id:"function",style:{position:"relative"}},r.createElement(n.a,{href:"#function","aria-label":"function permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.p,null,"Here is the function using above algorithm"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn longest_common_subsequence(string1:&Vec<char>, string2:&Vec<char>, n:usize, m:usize) -> usize {\n\n    // If there is no character in any of the string, return 0\n    if n==0 || m==0 {\n        return 0;\n    }\n\n    // If last character of both strings is same, we include that in our lcs\n    // Hence, we return 1 + lcs of remaining parts of both strings\n    if string1[n-1] == string2[m-1] {\n        return 1+longest_common_subsequence(string1, string2, n-1, m-1);\n    }\n\n    // Now, if the last character is not same, we check by removing 1 letter from each string\n    // And return their max as answer\n    return max( longest_common_subsequence(string1, string2, n-1, m),\n                longest_common_subsequence(string1, string2, n, m-1));\n}\n")),"\n",r.createElement(n.p,null,"With driver code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'use std::cmp::max;\nuse std::io;\n\nfn longest_common_subsequence(string1:&Vec<char>, string2:&Vec<char>, n:usize, m:usize) -> usize {\n\n    // If there is no character in any of the string, return 0\n    if n==0 || m==0 {\n        return 0;\n    }\n\n    // If last character of both strings is same, we include that in our lcs\n    // Hence, we return 1 + lcs of remaining parts of both strings\n    if string1[n-1] == string2[m-1] {\n        return 1+longest_common_subsequence(string1, string2, n-1, m-1);\n    }\n\n    // Now, if the last character is not same, we check by removing 1 letter from each string\n    // And return their max as answer\n    return max( longest_common_subsequence(string1, string2, n-1, m),\n                longest_common_subsequence(string1, string2, n, m-1));\n}\n// Driver Code\n\n// Take vector of characters\nfn take_string() -> Vec<char> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let vec:Vec<char> = input.trim().chars().collect();\n    return vec;\n}\n\nfn main() {\n\n    // Input String\n    let string1 = take_string();\n    let string2 = take_string();\n\n    // Print the length of longest common subsequence\n    println!("Length of longest common subsequence is : {}",\n             longest_common_subsequence(&string1, &string2, string1.len(), string2.len()));\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"abcdef ",r.createElement("br"),"\nacfbde"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"Length of longest common subsequence is : 4"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( 2",r.createElement("sup",null,"m+n")," )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( m+n )")),"\n",r.createElement(n.p,null,"( Space complexity includes recursive stack space )"),"\n",r.createElement(n.h2,{id:"overlapping-sub-problems",style:{position:"relative"}},r.createElement(n.a,{href:"#overlapping-sub-problems","aria-label":"overlapping sub problems permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overlapping Sub-problems"),"\n",r.createElement(n.p,null,"If we have a look carefully on recursive approach, we computed the LCS of multiple subsequence or substrings of original strings again and again. This is called overlapping sub-problems."),"\n",r.createElement(n.p,null,"For example, if we have to compute LCS of strings ",r.createElement(n.code,null,"abcdefghi")," and ",r.createElement(n.code,null,"jklmnopqr"),", the LCS of strings ",r.createElement(n.code,null,"abcd")," and ",r.createElement(n.code,null,"jklm")," is computed more than 1000 times, and takes hundreds of iterations each time."),"\n",r.createElement(n.p,null,"So, we simply store the result for each sub-problem, and return it if it is already computed, hence preventing it computing again and again."),"\n",r.createElement(n.p,null,"In the LCS problem, we take 2D matrix, such that matrix[i][j] contains the length of LCS of first ",r.createElement(n.code,null,"i")," characters of string1 with first ",r.createElement(n.code,null,"j")," characters of string2."),"\n",r.createElement(n.p,null,"For example, if the string1 is ",r.createElement(n.code,null,"abcdef")," and string 2 is ",r.createElement(n.code,null,"acfbde"),", then matrix[3][4] will contain length of LCS of strings ",r.createElement(n.code,null,"abc")," and ",r.createElement(n.code,null,"acfb")),"\n",r.createElement(n.h2,{id:"memoization--top-down-dp--method",style:{position:"relative"}},r.createElement(n.a,{href:"#memoization--top-down-dp--method","aria-label":"memoization  top down dp  method permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memoization ( Top-down DP ) Method"),"\n",r.createElement(n.p,null,"In memoization method, we simply take a DP matrix, and store the computed result."),"\n",r.createElement(n.h3,{id:"algorithm-1",style:{position:"relative"}},r.createElement(n.a,{href:"#algorithm-1","aria-label":"algorithm 1 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"Initially, set all the elements of dp matrix to -1. ( We do not set it to 0 because LCS of completely mismatch strings is also 0. Hence it will compute again and again)"),"\n",r.createElement(n.li,null,"If the length of LCS has already been found and stored in matrix, return the length of LCS."),"\n",r.createElement(n.li,null,"Else, compute the length of LCS and store it in DP matrix at dp[i][j], where i is length of string1 and j is length of string2."),"\n"),"\n",r.createElement(n.h3,{id:"function-1",style:{position:"relative"}},r.createElement(n.a,{href:"#function-1","aria-label":"function 1 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.p,null,"Here is the function using above algorithm"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn longest_common_subsequence(string1:&Vec<char>, string2:&Vec<char>, n:usize, m:usize, dp:&mut Vec<Vec<i64>>) -> i64 {\n\n    // If there is no character in any of the string, return 0\n    if n==0 || m==0 {\n        return 0;\n    }\n\n    // If already computed, return computed value\n    if dp[n][m]!=-1 {\n        return dp[n][m];\n    }\n\n    // If last character of both strings is same, we include that in our lcs\n    // Hence, we return 1 + lcs of remaining parts of both strings\n    if string1[n-1] == string2[m-1] {\n        dp[n][m] = 1+longest_common_subsequence(string1, string2, n-1, m-1, dp);\n        return dp[n][m];\n    }\n\n    // Now, if the last character is not same, we check by removing 1 letter from each string\n    // And return their max as answer\n    dp[n][m] = max( longest_common_subsequence(string1, string2, n-1, m, dp),\n                    longest_common_subsequence(string1, string2, n, m-1, dp));\n    return dp[n][m];\n}\n")),"\n",r.createElement(n.p,null,"With Driver code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'use std::cmp::max;\nuse std::io;\n\nfn longest_common_subsequence(string1:&Vec<char>, string2:&Vec<char>, n:usize, m:usize, dp:&mut Vec<Vec<i64>>) -> i64 {\n\n    // If there is no character in any of the string, return 0\n    if n==0 || m==0 {\n        return 0;\n    }\n\n    // If already computed, return computed value\n    if dp[n][m]!=-1 {\n        return dp[n][m];\n    }\n\n    // If last character of both strings is same, we include that in our lcs\n    // Hence, we return 1 + lcs of remaining parts of both strings\n    if string1[n-1] == string2[m-1] {\n        dp[n][m] = 1+longest_common_subsequence(string1, string2, n-1, m-1, dp);\n        return dp[n][m];\n    }\n\n    // Now, if the last character is not same, we check by removing 1 letter from each string\n    // And return their max as answer\n    dp[n][m] = max( longest_common_subsequence(string1, string2, n-1, m, dp),\n                    longest_common_subsequence(string1, string2, n, m-1, dp));\n    return dp[n][m];\n}\n\n// Driver Code\n\n// Take vector of characters\nfn take_string() -> Vec<char> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let vec:Vec<char> = input.trim().chars().collect();\n    return vec;\n}\n\nfn main() {\n\n    // Input String\n    let string1 = take_string();\n    let string2 = take_string();\n\n    // Make a DP array\n    let n = string1.len();\n    let m = string2.len();\n\n    // We are making a vector of vectors with n rows and m columns\n    // We set each element to -1 initially\n    // If we take 0, its complexity will become 2^(m+n) in the worst case\n    // Because if strings mismatch, there LCS is also 0\n    let mut dp = vec![vec![-1 as i64; m+1];n+1];\n\n    // Print the length of longest common subsequence\n    println!("Length of longest common subsequence is : {}",\n             longest_common_subsequence(&string1, &string2, string1.len(), string2.len() , &mut dp));\n\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"abcdef ",r.createElement("br"),"\nacfbde"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"Length of longest common subsequence is : 4"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( m*n )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( m*n )")),"\n",r.createElement(n.h2,{id:"tabulation---bottom-up-dp---method",style:{position:"relative"}},r.createElement(n.a,{href:"#tabulation---bottom-up-dp---method","aria-label":"tabulation   bottom up dp   method permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tabulation  ( Bottom-up DP )  Method"),"\n",r.createElement(n.p,null,"Although time and space complexities of tabulation as well as memoization method are same, tabulation is much more efficient as there are a lot of expensive recursive calls in memoization."),"\n",r.createElement(n.p,null,"In tabulation method, we make the matrix, and fill it on the basis of base condition, and then on the basis of LCS of previous values."),"\n",r.createElement(n.h2,{id:"algorithm-2",style:{position:"relative"}},r.createElement(n.a,{href:"#algorithm-2","aria-label":"algorithm 2 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithm"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"Initially, set all the elements of all the columns and rows to 0, because LCS = 0 if either of string is empty."),"\n",r.createElement(n.li,null,"For i",r.createElement("sup",null,"th")," row and j",r.createElement("sup",null,"th")," column, if string1[i] == string2[j], then set dp[i][j] = 1+dp[i-1][j-1]."),"\n",r.createElement(n.li,null,"Else, set dp[i][j] = maximum of dp[i][j-1] and dp[i-1][j]"),"\n"),"\n",r.createElement(n.p,null,"If we traverse the matrix either row-wise or column-wise, it is always guaranteed that dp[i-1][j-1], dp[i][j-1] and dp[i-1][j] are already processed, hence ensuring our answer is correct."),"\n",r.createElement(n.h3,{id:"function-2",style:{position:"relative"}},r.createElement(n.a,{href:"#function-2","aria-label":"function 2 permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Function"),"\n",r.createElement(n.p,null,"Here is the function using above algorithm"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn longest_common_subsequence(string1:&Vec<char>, string2:&Vec<char>, n:usize, m:usize, dp:&mut Vec<Vec<i64>>) -> i64 {\n\n    // Set all the elements in 0th row and column to 0\n    for i in 0..m+1 { dp[0][i] = 0; }\n    for i in 0..n+1 { dp[i][0] = 0; }\n\n    // Traverse each row and column, row wise\n\n    for i in 1..n+1 {\n        for j in 1..m+1 {\n\n            // If both string have same character, dp[i][j] = dp[i-1][j-1]\n            if string1[i-1] == string2[j-1] {\n                dp[i][j] = 1+dp[i-1][j-1];\n            }\n\n            // Else, find maximum of dp[i-1][j] and dp[i][j-1]\n            else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n\n        }\n    }\n\n    return dp[n][m];\n}\n")),"\n",r.createElement(n.p,null,"Use the same driver code."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"abcdef ",r.createElement("br"),"\nacfbde"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"Length of longest common subsequence is : 4"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( m*n )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( m*n )")),"\n",r.createElement(n.p,null,"Though time and space complexities are same as memoization method, yet it is much more optimized than memoization method."),"\n",r.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},r.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",r.createElement(n.p,null,"Longest Common Subsequence is a classical Dynamic Programming problem, in which we have to find the length of longest common subsequence of the given strings."),"\n",r.createElement(n.p,null,"In this article, we saw how to find Longest Common Subsequence ( LCS ) of two strings, first using Recursion and then using Dynamic Programming methods, Memoization as well as Tabulation method in Rust Language."),"\n",r.createElement(n.p,null,"Here is the optimized function for easy access"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn longest_common_subsequence(string1:&Vec<char>, string2:&Vec<char>, n:usize, m:usize, dp:&mut Vec<Vec<i64>>) -> i64 {\n    for i in 0..m+1 { dp[0][i] = 0; }\n    for i in 0..n+1 { dp[i][0] = 0; }\n    for i in 1..n+1 {\n        for j in 1..m+1 {\n            if string1[i-1] == string2[j-1] { dp[i][j] = 1+dp[i-1][j-1]; }\n            else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); }\n        }\n    }\n    return dp[n][m];\n}\n")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Thank You")),"\n","\n",r.createElement(a.H,{title:"Longest Common Subsequence ( LCS ) using Memoization and Tabulation - Dynamic Programming - Rust Programming",description:"In this article, we will see how to find length of Longest Common Subsequence of given strings, first using recursion, and then using dynamic programming methods, Memoization as well as Tabulation, in Rust Language"}))}var s=function(e){void 0===e&&(e={});var n=Object.assign({},(0,l.ah)(),e.components).wrapper;return n?r.createElement(n,e,r.createElement(i,e)):i(e)};function o(e){return e.children}function c(e){return r.createElement(o,e,r.createElement(s,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-2-dynamic-programming-longest-common-subsequence-mdx-0bc809d172ede3311d32.js.map