"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[87],{68615:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var r=t(27378),a=t(20951),i=t.p+"static/prime-factorization-f3ed92b4fa7cd7ec955709a8dee4e696.webp",l=t(88957);function o(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",ol:"ol",li:"li",pre:"pre",code:"code",blockquote:"blockquote",em:"em"},(0,a.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h1,{id:"prime-factorization-of-a-natural-number",style:{position:"relative"}},r.createElement(n.a,{href:"#prime-factorization-of-a-natural-number","aria-label":"prime factorization of a natural number permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Prime Factorization of a natural number"),"\n",r.createElement(n.p,null,"And a program in Rust to list all the prime factors of a natural number"),"\n",r.createElement(n.h2,{id:"what-is-prime-factorization-of-a-number",style:{position:"relative"}},r.createElement(n.a,{href:"#what-is-prime-factorization-of-a-number","aria-label":"what is prime factorization of a number permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"What is Prime Factorization of a number"),"\n",r.createElement(n.p,null,"Prime Factorization of a natural number is splitting the number into its factors, which are prime numbers. It can also be understood as writing a natural number as the product of prime numbers."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"For Example :"),"  100 = 2",r.createElement("sup",null,"2")," Ã— 5",r.createElement("sup",null,"2")),"\n","\n",r.createElement("div",{style:{textAlign:"center"}},r.createElement("img",{src:i,width:"100%",alt:"Prime Factorization of 720"})),"\n",r.createElement(n.h2,{id:"approach",style:{position:"relative"}},r.createElement(n.a,{href:"#approach","aria-label":"approach permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approach"),"\n",r.createElement(n.p,null,"Using BTreeMap"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"While number is divisible by 2, add 2 to prime factors and divide the number by 2."),"\n",r.createElement(n.li,null,"Now, number is odd number. So, start from 3, and go till square root of number,  perform the step 3."),"\n",r.createElement(n.li,null,"While i divides number, simply add i to prime factors."),"\n",r.createElement(n.li,null,"If the number, after loop, does not become 1, number that is left, itself is a prime number."),"\n"),"\n",r.createElement(n.h2,{id:"program",style:{position:"relative"}},r.createElement(n.a,{href:"#program","aria-label":"program permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Program"),"\n",r.createElement(n.p,null,"Program using above approach is given below :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"pub fn prime_factorization(mut number:i128) -> BTreeMap<i128, i128> {\n    let mut prime_factors: BTreeMap<i128, i128> = BTreeMap::new();\n\n    // Step 1 : Divide by 2\n    let mut freq:i128 = 0;\n\n    // You can use number % 2 == 0 also,\n    // but this method is much more efficient\n    while number&1 == 0 {\n        number >>=1;\n        // Again, You can use number /= 2 also,\n        // but this is much more efficient\n        freq+=1;\n    }\n\n    if freq > 0 {\n        prime_factors.insert(2, freq);\n    }\n\n    // Step 2 : start from 3, and go till square root of number\n    let mut i = 3;\n    while i*i <= number {\n\n        // Step 3 : Check if i is factor of number\n        if number%i==0 {\n            freq = 0;\n            while number%i==0 {\n                number/=i;\n                freq+=1;\n            }\n            prime_factors.insert(i, freq);\n        }\n        i+=2;\n    }\n\n    // Step 4 : Check if number become 1 or not\n    if number > 1 {\n        prime_factors.insert(number, 1);\n    }\n\n    return prime_factors;\n}\n")),"\n",r.createElement(n.p,null,"Program With Driver Code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'use std::collections::BTreeMap;\nuse std::io::stdin;\n\nfn take_int() -> i128 {\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    input.trim().parse().unwrap()\n}\n\n// Magic starts here\n\npub fn prime_factorization(mut number:i128) -> BTreeMap<i128, i128> {\n    let mut prime_factors: BTreeMap<i128, i128> = BTreeMap::new();\n\n    // Step 1 : Divide by 2\n    let mut freq:i128 = 0;\n\n    // You can use number % 2 == 0 also,\n    // but this method is much more efficient\n    while number&1 == 0 {\n        number >>=1;\n        // Again, You can use number /= 2 also,\n        // but this is much more efficient\n        freq+=1;\n    }\n\n    if freq > 0 {\n        prime_factors.insert(2, freq);\n    }\n\n    // Step 2 : start from 3, and go till square root of number\n    let mut i = 3;\n    while i*i <= number {\n\n        // Step 3 : Check if i is factor of number\n        if number%i==0 {\n            freq = 0;\n            while number%i==0 {\n                number/=i;\n                freq+=1;\n            }\n            prime_factors.insert(i, freq);\n        }\n        i+=2;\n    }\n\n    // Step 4 : Check if number become 1 or not\n    if number > 1 {\n        prime_factors.insert(number, 1);\n    }\n\n    return prime_factors;\n}\n\n// Driver Code Starts\n\npub fn main() {\n    // Take input\n    let number = take_int();\n\n    // Call Our function\n    let prime_factors = prime_factorization(number);\n\n    // Print result\n    for (key, value) in prime_factors {\n        println!("{} appears {} time", key, value);\n    }\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Input")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"720"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"2 appears 4 time ",r.createElement("br"),"\n3 appears 2 time ",r.createElement("br"),"\n5 appears 1 time"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O( sqrt(n) )")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O( sqrt(n) )")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Note :")," We can print the number instead of storing into the BtreeMap, to reduce ",r.createElement(n.strong,null,"Space Complexity to O(1)")," but it is rarely useful. BTreeMap or vector of prime factors is far more useful in real applications, so I will demonstrate BTreeMap, instead of printing directly."),"\n",r.createElement(n.p,null,"You can also modify the code to use ",r.createElement(n.em,null,"HashMap")," or ",r.createElement(n.em,null,"Vector")," or ",r.createElement(n.em,null,"BTreeSet")," or ",r.createElement(n.em,null,"HashSet"),", according to your requirement."),"\n",r.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},r.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",r.createElement(n.p,null,"Prime Factorization of a natural number is splitting the number into the product of prime numbers. It is used for various applications."),"\n",r.createElement(n.p,null,"In this article, we made a function to generate all the prime factors of a number and store them with their respective exponents. Here is the function for easy access"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"pub fn prime_factorization(mut number:i128) -> BTreeMap<i128, i128> {\n    let mut prime_factors: BTreeMap<i128, i128> = BTreeMap::new();\n    let mut freq:i128 = 0;\n    while number&1 == 0 {\n        number>>=1;\n        freq+=1;\n    }\n    if freq > 0 { prime_factors.insert(2, freq);}\n    let mut i = 3;\n    while i*i <= number {\n        if number%i==0 {\n            freq = 0;\n            while number%i==0 {\n                number/=i;\n                freq+=1;\n            }\n            prime_factors.insert(i, freq);\n        }\n        i+=2;\n    }\n    if number > 1 {prime_factors.insert(number, 1);}\n\n    return prime_factors;\n}\n")),"\n",r.createElement(n.p,null,"Above program runs on O( sqrt (n) ) time complexity. We can also optimize the code using sieve method, which we will discuss later."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Thank You")),"\n","\n",r.createElement(l.H,{title:"Prime Factorization of a natural number - Rust Programming",description:"Prime Factorization of a natural number is splitting the number into its factors, which are prime numbers. Here, we will make a function to list all the prime factors of a natural number in Rust using BTreeMap"}))}var m=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?r.createElement(n,e,r.createElement(o,e)):o(e)};function c(e){return e.children}function u(e){return r.createElement(c,e,r.createElement(m,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-2-number-theory-2-2-factors-of-number-prime-factorization-of-a-number-mdx-83fbca7fb99d6a8934a7.js.map