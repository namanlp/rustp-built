"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9917],{16493:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var r=t(27378),l=t(20951),a=t(88957);function i(e){var n=Object.assign({h1:"h1",a:"a",div:"div",p:"p",h2:"h2",strong:"strong",ul:"ul",li:"li",code:"code",pre:"pre",em:"em",h3:"h3",blockquote:"blockquote"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h1,{id:"modular-factorial",style:{position:"relative"}},r.createElement(n.a,{href:"#modular-factorial","aria-label":"modular factorial permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Modular Factorial"),"\n",r.createElement(n.p,null,"of a number and Program to find modular factorial using Modular Arithmetic in Rust."),"\n",r.createElement(n.h2,{id:"why-do-we-need-modulo",style:{position:"relative"}},r.createElement(n.a,{href:"#why-do-we-need-modulo","aria-label":"why do we need modulo permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why do we need Modulo"),"\n",r.createElement(n.p,null,"The program discussed in ",r.createElement(n.a,{href:"/number-theory/factorial-of-number/"},"Finding Factorial Of a Number")," page finds the factorial of a given number. But factorial of number grows very fast with number. ",r.createElement(n.strong,null,"Factorial of 100 is 9.33 × 10",r.createElement("sup",null,"157")),"\nSo, it becomes impossible to store such large number as number in many languages, like ",r.createElement(n.strong,null,"C, C++, Rust")," etc. ( Though some languages like Python allow number of any length being stored )."),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"Largest integer data type in rust is ",r.createElement(n.code,null,"i128")," which can store only the numbers of 128 bits which is roughly of order ",r.createElement(n.strong,null,r.createElement("code",null,"10",r.createElement("sup",null,"38")))," ",r.createElement("br")," ",r.createElement("br")),"\n",r.createElement(n.li,null,"If we try to store a number beyond this range, ",r.createElement(n.strong,null,"the number will overflow, and an error will be thrown!.")," Like, if we try to find 100!"),"\n"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},"thread 'main' panicked at 'attempt to multiply with overflow', src/iterative.rs:10:9\n")),"\n",r.createElement(n.p,null,"Therefore, we must find an alternate to store and use the factorial of larger numbers."),"\n",r.createElement(n.h2,{id:"using-modulo-of-number-to-store",style:{position:"relative"}},r.createElement(n.a,{href:"#using-modulo-of-number-to-store","aria-label":"using modulo of number to store permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Using Modulo of Number to store"),"\n",r.createElement(n.p,null,"As we saw above, we can not store the complete number. But we can store it's modulo from a number."),"\n",r.createElement(n.p,null,"In most programming contest, a specific number is mentioned, generally ",r.createElement(n.strong,null,r.createElement("code",null,"10",r.createElement("sup",null,"9")," + 7 or 1000000007"))," is used because It is ",r.createElement(n.em,null,"safe prime number"),"."),"\n",r.createElement(n.p,null,"But we will see a function that generates factorial of a number modulo any other number. Also, it is guaranteed that number will be less than the second number. That is, if we find factorial modulo 13, it is guaranteed that the answer will be less than 13.\nHence, it will ensure that the number doesn't overflow."),"\n",r.createElement(n.h3,{id:"property-used",style:{position:"relative"}},r.createElement(n.a,{href:"#property-used","aria-label":"property used permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Property Used"),"\n",r.createElement(n.p,null,"We take the help of special property in Modular Mathematics, which is called Modular Multiplication Property\n",r.createElement("center",null," ",r.createElement("b",null,"(a x b) mod m = ((a mod m) x (b mod m)) mod m")," ")),"\n",r.createElement(n.p,null,"Also, we know that ",r.createElement(n.strong,null,"n! = n × (n-1)!"),". Therefore,\n",r.createElement(n.strong,null,"n! mod m = ((n mod m) x ((n-1)! mod m)) mod m")),"\n",r.createElement(n.p,null,"Also, ",r.createElement(n.code,null,"n mod m = n")," because if n is greater or equal to m, final result will be 0, because n! will already contain m, and hence, it is always divisible by m."),"\n",r.createElement(n.p,null,"If n is less than m, than n mod m = n always."),"\n",r.createElement(n.p,null,"Also, (n-1)! is already modulo m. So, no need to find modulo m again.So, finally, we use equation"),"\n",r.createElement("center",null," ",r.createElement("b",null,"n! mod m = ( n x (n-1)! ) mod m")," "),"\n",r.createElement(n.h2,{id:"recursive-approach",style:{position:"relative"}},r.createElement(n.a,{href:"#recursive-approach","aria-label":"recursive approach permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Recursive Approach"),"\n",r.createElement(n.p,null,"In the code seen in ",r.createElement(n.a,{href:"/number-theory/factorial-of-number/"},"Finding Factorial of a Number")," page, we just ",r.createElement(n.strong,null,"return number modulo divisor")),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"\nfn factorial_recursive(number : i128, divisor: i128) -> i128{\n\n    // Base Case\n    if number<=1 {\n        return 1;\n    }\n\n    // Recursive Case\n    return (number * factorial_recursive(number-1, divisor) ) % divisor;\n}\n")),"\n",r.createElement(n.p,null,"Program with Driver Code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},'use std::io::stdin;\n\nfn factorial_recursive(number : i128, divisor: i128) -> i128{\n\n    // Base Case\n    if number<=1 {\n        return 1;\n    }\n\n    // Recursive Case\n    return (number * factorial_recursive(number-1, divisor) ) % divisor;\n}\n\n// Driver Code\n\npub fn main() {\n\n    // Read and parse number to i128\n    let mut input = String::new();\n    stdin().read_line(&mut input).unwrap();\n    let number : i128 = input.trim().parse().unwrap();\n\n    input.clear();\n\n    stdin().read_line(&mut input).unwrap();\n    let divisor : i128 = input.trim().parse().unwrap();\n\n    // Find and print factorial\n    let factorial = factorial_recursive(number, divisor);\n    println!("Factorial of {} is : {}", number,  factorial);\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"12345 ",r.createElement("br"),"\n1000000007 ",r.createElement("br"),"\nFactorial of 12345 is : 579592771"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O(n)")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O(n)")),"\n",r.createElement(n.p,null,"As you can see, we can easily find factorial of number as large as ",r.createElement(n.code,null,"12345")," modulo some other number easily."),"\n",r.createElement(n.h2,{id:"iterative-approach",style:{position:"relative"}},r.createElement(n.a,{href:"#iterative-approach","aria-label":"iterative approach permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Iterative Approach"),"\n",r.createElement(n.p,null,"In this, we multiply all the number from 1 to the given number, and each time store the remainder."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn factorial(number : i128, divisor: i128) -> i128{\n\n    // initialize factorial to 1, explicitly type i128\n    let mut factorial : i128 = 1;\n\n    // Multiply factorial by all numbers from 1 to the given number\n    for i in 1..(number+1) {\n        factorial*=i;\n        // Find remainder\n        factorial%=divisor;\n    }\n\n    // Return factorial\n    return factorial\n}\n")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Output")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"12345 ",r.createElement("br"),"\n1000000007 ",r.createElement("br"),"\nFactorial of 12345 is : 579592771"),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Time Complexity : O(n)")," ",r.createElement("br"),"\n",r.createElement(n.strong,null,"Space Complexity : O(1)")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Note :")," Iterative approach is more efficient than recursive approach !"),"\n",r.createElement(n.h2,{id:"conclusion",style:{position:"relative"}},r.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",r.createElement(n.p,null,"This article covered how to find factorial of very large numbers, using both Iterative and recursive methods in rust."),"\n",r.createElement(n.p,null,"Here is function for easy access"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-rust"},"fn factorial(number : i128, divisor: i128) -> i128{\n    let mut factorial : i128 = 1;\n    for i in 1..(number+1) {\n        factorial*=i;\n        factorial%=divisor;\n    }\n    return factorial\n}\n")),"\n",r.createElement(n.p,null,"In the next article, we will see how to find the factorial of multiple numbers."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Thank You")),"\n","\n",r.createElement(a.H,{title:"Modular Factorial - Rust Programming",description:"Factorial is an important value of a number. But calculating factorial of large numbers can result in overflow. In this article, we calculate modular factorial of large numbers using Modular Arithmetic in Rust."}))}var o=function(e){void 0===e&&(e={});var n=Object.assign({},(0,l.ah)(),e.components).wrapper;return n?r.createElement(n,e,r.createElement(i,e)):i(e)};function c(e){return e.children}function u(e){return r.createElement(c,e,r.createElement(o,e))}}}]);
//# sourceMappingURL=component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-3-combinatorics-modular-factorial-mdx-7c48fe1d0526b1d17025.js.map