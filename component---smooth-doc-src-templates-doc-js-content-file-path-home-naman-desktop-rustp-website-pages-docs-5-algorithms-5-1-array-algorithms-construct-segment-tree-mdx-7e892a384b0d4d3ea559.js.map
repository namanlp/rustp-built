{"version":3,"file":"component---smooth-doc-src-templates-doc-js-content-file-path-home-naman-desktop-rustp-website-pages-docs-5-algorithms-5-1-array-algorithms-construct-segment-tree-mdx-7e892a384b0d4d3ea559.js","mappings":"0LAIA,SAASA,EAAkBC,GACzB,IAAMC,EAAcC,OAAOC,OAAO,CAChCC,GAAI,KACJC,EAAG,IACHC,IAAK,MACLC,EAAG,IACHC,GAAI,KACJC,OAAQ,SACRC,GAAI,KACJC,GAAI,KACJC,GAAI,KACJC,IAAK,MACLC,KAAM,OACNC,GAAI,KACJC,GAAI,OACHC,EAAAA,EAAAA,MAAsBjB,EAAMkB,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBlB,EAAYG,GAAI,CACnFgB,GAAI,+BACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,gCACN,aAAc,yCACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,gCAAiC,KAAMP,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,mDAAoD,KAAMY,EAAAA,cAAoBlB,EAAYO,GAAI,CACjLY,GAAI,eACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,gBACN,aAAc,yBACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,gBAAiB,KAAMP,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,iFAAkFY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,iBAAkB,sFAAuF,KAAMU,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,mFAAoFY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,cAAe,gBAAiBU,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,UAAW,wBAAyBU,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,UAAW,qBAAsB,KAAMU,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,uDAAwD,KAAMY,EAAAA,cAAoBlB,EAAYS,GAAI,KAAM,KAAMS,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,6CAA8C,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,8CAA+C,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,qCAAsC,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,6BAA8B,MAAO,KAAMQ,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,kGAAmG,KAAMY,EAAAA,cAAoBlB,EAAYO,GAAI,CACz1CY,GAAI,uBACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,wBACN,aAAc,iCACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,wBAAyB,KAAMP,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,gCAAiCY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,KAAM,sCAAuC,KAAMU,EAAAA,cAAoBlB,EAAYW,GAAI,KAAM,KAAMO,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,+BAAgC,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,uFAAwF,MAAO,KAAMQ,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,8EAA+E,KAAMY,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,yEAA0EY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,WAAY,KAAMU,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,0EAA2E,KAAMY,EAAAA,cAAoBlB,EAAYY,IAAK,KAAMM,EAAAA,cAAoBlB,EAAYa,KAAM,CACx9BU,UAAW,iBACV,4gBAA6gB,KAAML,EAAAA,cAAoBlB,EAAYO,GAAI,CACxjBY,GAAI,4BACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,6BACN,aAAc,sCACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,6BAA8B,KAAMP,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,4BAA6BY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,eAAgB,sIAAuI,KAAMU,EAAAA,cAAoBlB,EAAYM,EAAG,KAAMY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,iBAAkB,6BAA8BU,EAAAA,cAAoBlB,EAAYc,GAAI,KAAM,KAAM,uKAAwK,KAAMI,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,+FAAgG,KAAMY,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,wEAAyE,KAAMY,EAAAA,cAAoBlB,EAAYW,GAAI,KAAM,KAAMO,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,uDAAwD,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,wDAAyD,MAAO,KAAMQ,EAAAA,cAAoBlB,EAAYO,GAAI,CAChtCY,GAAI,8BACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,+BACN,aAAc,wCACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,+BAAgC,KAAMP,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,sGAAuG,KAAMY,EAAAA,cAAoBlB,EAAYe,GAAI,CACnOI,GAAI,YACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,aACN,aAAc,sBACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,aAAc,KAAMP,EAAAA,cAAoBlB,EAAYS,GAAI,KAAM,KAAMS,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,gHAAiH,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,8FAA+F,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,wJAAyJ,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,4HAA6H,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,6HAA8H,KAAMQ,EAAAA,cAAoBlB,EAAYU,GAAI,KAAM,8CAA+CQ,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,oBAAqB,6BAA8B,MAAO,KAAMU,EAAAA,cAAoBlB,EAAYe,GAAI,CACtoCI,GAAI,WACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,YACN,aAAc,qBACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,YAAa,KAAMP,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,uGAAwG,KAAMY,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,8BAA+BY,EAAAA,cAAoBlB,EAAYa,KAAM,KAAM,4BAA6B,+DAAgEK,EAAAA,cAAoBlB,EAAYa,KAAM,KAAM,KAAM,4BAA6B,KAAMK,EAAAA,cAAoBlB,EAAYM,EAAG,KAAMY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,UAAW,4DAA6DU,EAAAA,cAAoBlB,EAAYa,KAAM,KAAM,iCAAkC,cAAe,KAAMK,EAAAA,cAAoBlB,EAAYY,IAAK,KAAMM,EAAAA,cAAoBlB,EAAYa,KAAM,CACtyBU,UAAW,iBACV,yjDAA0jD,KAAML,EAAAA,cAAoBlB,EAAYM,EAAG,KAAMY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,4BAA6B,IAAKU,EAAAA,cAAoB,MAAO,KAAMA,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,8BAA+B,KAAMU,EAAAA,cAAoBlB,EAAYO,GAAI,CACl1DY,GAAI,aACJC,MAAO,CACLC,SAAU,aAEXH,EAAAA,cAAoBlB,EAAYI,EAAG,CACpCkB,KAAM,cACN,aAAc,uBACdC,UAAW,iBACVL,EAAAA,cAAoBlB,EAAYK,IAAK,CACtCmB,wBAAyB,CACvBC,OAAQ,meAEP,cAAe,KAAMP,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,iHAAkH,KAAMY,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,0DAA2DY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,cAAe,SAAUU,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,UAAW,cAAeU,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,UAAW,qHAAsH,KAAMU,EAAAA,cAAoBlB,EAAYM,EAAG,KAAM,uKAAwK,KAAMY,EAAAA,cAAoBlB,EAAYY,IAAK,KAAMM,EAAAA,cAAoBlB,EAAYa,KAAM,CACz4BU,UAAW,iBACV,wyBAAyyB,KAAML,EAAAA,cAAoBlB,EAAYM,EAAG,KAAMY,EAAAA,cAAoBlB,EAAYQ,OAAQ,KAAM,cAAe,KAAM,KAAMU,EAAAA,cAAoBQ,EAAAA,EAAK,CAC37BC,MAAO,iDACPC,YAAa,iNAEhB,CAKD,MAJA,SAAoB7B,QAAY,IAAZA,IAAAA,EAAQ,CAAC,GAC3B,IAAgB8B,EAAa5B,OAAOC,OAAO,CAAC,GAAGc,EAAAA,EAAAA,MAAsBjB,EAAMkB,YAApEa,QACP,OAAOD,EAAYX,EAAAA,cAAoBW,EAAW9B,EAAOmB,EAAAA,cAAoBpB,EAAmBC,IAAUD,EAAkBC,EAC7H,EC3HD,SAASgC,EAAT,GACE,OAD+B,EAAXC,QAErB,CAEc,SAASC,EAAiBlC,GACvC,OAAOmB,EAAAA,cAAoBa,EAAahC,EAAOmB,EAAAA,cAAoBgB,EAAqBnC,GACzF,C","sources":["webpack://website/./pages/docs/5 Algorithms/5.1 Array Algorithms/Construct-Segment-Tree.mdx","webpack://website/../smooth-doc/src/templates/doc.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nimport {SEO} from \"smooth-doc/src/components/SEO\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    a: \"a\",\n    div: \"div\",\n    p: \"p\",\n    h2: \"h2\",\n    strong: \"strong\",\n    ol: \"ol\",\n    li: \"li\",\n    ul: \"ul\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h1, {\n    id: \"introduction-to-segment-tree\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#introduction-to-segment-tree\",\n    \"aria-label\": \"introduction to segment tree permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Introduction to Segment Tree\"), \"\\n\", React.createElement(_components.p, null, \"and program to construct a segment tree in Rust\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"introduction\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Introduction\"), \"\\n\", React.createElement(_components.p, null, \"The Segment Tree is a commonly used tree like data structure that is used for \", React.createElement(_components.strong, null, \"range queries\"), \" or subarray queries, like minimum element or sum of elements in a given subarray.\"), \"\\n\", React.createElement(_components.p, null, \"By using the Segment Tree, we can reduce the time taken for each range query to \", React.createElement(_components.strong, null, \"O( log n )\"), \", that takes \", React.createElement(_components.strong, null, \"O( n )\"), \" otherwise, but uses \", React.createElement(_components.strong, null, \"O( n )\"), \" auxiliary space.\"), \"\\n\", React.createElement(_components.p, null, \"The example of range queries on a given array are :\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"Sum/Product of integers in a given range.\"), \"\\n\", React.createElement(_components.li, null, \"Bitwise OR/AND of integers in given range.\"), \"\\n\", React.createElement(_components.li, null, \"Minimum/Maximum in a given range.\"), \"\\n\", React.createElement(_components.li, null, \"LCM/GCD in a given range.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"If you got any of these queries to perform in Logarithmic time, segment tree is a good option.\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"size-of-segment-tree\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#size-of-segment-tree\",\n    \"aria-label\": \"size of segment tree permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Size of Segment Tree\"), \"\\n\", React.createElement(_components.p, null, \"For a given array containing \", React.createElement(_components.strong, null, \"n\"), \" integers, size of segment tree is\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"2n-1 : If n is a power of 2\"), \"\\n\", React.createElement(_components.li, null, \"2k-1 : If n is not the power of 2, and k is the smallest power of 2 greater than n.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"So, for example, if n = 9 => k = 16, and hence, size of segment tree = 31.\"), \"\\n\", React.createElement(_components.p, null, \"Also, it is not hard to see that space complexity of a segment tree = \", React.createElement(_components.strong, null, \"O( n )\")), \"\\n\", React.createElement(_components.p, null, \"Here is the function to calculate the height of a Segment Tree in Rust\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn calc_size(n:usize)->usize{\\n    // If n is a power of 2, return 2n-1\\n    if n.count_ones() == 1 {\\n        // Left shift is used to multiply n by 2.\\n        return (n<<1)-1;\\n    }\\n\\n    // k denotes the height of the tree.\\n\\n    // If n is not the power of 2, we have to take 2*k - 1\\n    // k can be calculated by 2^(position of MSB+1)\\n    // For example, for n = 7, position of MSB = 2, so k = 8\\n    // Hence k = 2^(64 - leading zeroes)\\n\\n    let k = 1<<(64 - n.leading_zeros());\\n    return (k<<1)-1;\\n}\\n\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"structure-of-segment-tree\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#structure-of-segment-tree\",\n    \"aria-label\": \"structure of segment tree permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Structure of Segment Tree\"), \"\\n\", React.createElement(_components.p, null, \"The Segment Trees have a \", React.createElement(_components.strong, null, \"Binary Tree\"), \" like structure, where each node has at most two children, each representing the left and right half of parent range respectively.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"For Example :\"), \" If a node represents the \", React.createElement(_components.em, null, \"N\"), \" elements from [0..N-1] ( inclusive ), then its Left Child will represent the elements from [0..N/2-1] and right child will represent the elements from [N/2..N-1].\"), \"\\n\", React.createElement(_components.p, null, \"Hence, we keep on dividing each node, until the node is representing a single element only.\"), \"\\n\", React.createElement(_components.p, null, \"Also, we store the elements in the array form. So, for ith node, its\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"Left Node is represented by element at index 2*i +1\"), \"\\n\", React.createElement(_components.li, null, \"Right Node is represented by element at index 2*i +2\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"constructing-a-segment-tree\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#constructing-a-segment-tree\",\n    \"aria-label\": \"constructing a segment tree permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Constructing a segment tree\"), \"\\n\", React.createElement(_components.p, null, \"Before we can perform our Range Queries, we have to construct a Segment Tree from the given array.\"), \"\\n\", React.createElement(_components.h3, {\n    id: \"algorithm\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#algorithm\",\n    \"aria-label\": \"algorithm permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Algorithm\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"Calculate the size of segment tree and initialize an empty array/vector for segment tree with default value.\"), \"\\n\", React.createElement(_components.li, null, \"Initially, set low to 0, high to n-1 and position to 0, where size of original array is n.\"), \"\\n\", React.createElement(_components.li, null, \"If high is equal to low, then the current range represent only 1 element, and hence update it on the given position in the segment tree, and return.\"), \"\\n\", React.createElement(_components.li, null, \"If high is greater than low, then the current range represent 2 or more elements. So, we divide the range into 2 halves.\"), \"\\n\", React.createElement(_components.li, null, \"Recursively follow the steps 3 and 4 for left and right half of the range, for position 2×pos+1 and 2×pos+2 respectively.\"), \"\\n\", React.createElement(_components.li, null, \"Now, set the node at position to result of \", React.createElement(_components.strong, null, \"desired operator\"), \" of left and right child.\"), \"\\n\"), \"\\n\", React.createElement(_components.h3, {\n    id: \"function\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#function\",\n    \"aria-label\": \"function permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Function\"), \"\\n\", React.createElement(_components.p, null, \"The program using above algorithm is given below. I used Multiplication operator for the reference.\"), \"\\n\", React.createElement(_components.p, null, \"All you have to do is call \", React.createElement(_components.code, null, \"construct_segment_tree()\"), \" function, and pass the reference to the original array and \", React.createElement(_components.code, null, \"n\"), \", the size of the array.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Note :\"), \" To change the operator, you can change the last line of \", React.createElement(_components.code, null, \"construct_segment_tree_util()\"), \" function.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn calc_size(n:usize) ->usize{\\n    if n.count_ones() == 1 { return (n<<1)-1; }\\n    let k = 1<<(64 - n.leading_zeros());\\n    return (k<<1)-1;\\n}\\n\\n// I am taking Vector of unsigned integers.\\n// You can take it as per your requirement\\nfn construct_segment_tree(arr:&Vec<usize>) -> Vec<usize> {\\n    // Calculate the size of the segment tree array first\\n    let n = arr.len();\\n    let s = calc_size(n);\\n\\n    // Initialize the segment tree as an array of size s, and all elements are 0\\n    let mut segment_tree = vec![0 as usize; s];\\n\\n    // Now, call the construct_segment_tree_util function to build the tree\\n    // Note : we use n-1 here, because we are using inclusive range.\\n    construct_segment_tree_util(arr, &mut segment_tree, 0, n-1, 0);\\n\\n    return segment_tree;\\n}\\n\\nfn construct_segment_tree_util(arr:&Vec<usize>, tree:&mut Vec<usize>, low:usize, high:usize, pos:usize){\\n    // The range is empty\\n    if high<low { return; }\\n\\n    // Only 1 element in the range.\\n    // So, this is right position for the element\\n    if high == low {\\n        tree[pos] = arr[low];\\n        return;\\n    }\\n\\n    // Now, multiple elements exist in the given range.\\n    // So, recursively perform this function for left and right half of range\\n    let mid = (high+low)/2;\\n\\n    construct_segment_tree_util(arr, tree, low, mid, pos*2+1);\\n    construct_segment_tree_util(arr, tree, mid+1, high, pos*2+2);\\n\\n    // Here, you can change operation as per requirement\\n    // I am using multiplication operator for reference\\n    tree[pos] = tree[pos*2+1]*tree[pos*2+2];\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Time Complexity : O( n )\"), \" \", React.createElement(\"br\"), \"\\n\", React.createElement(_components.strong, null, \"Space Complexity : O( n )\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"conclusion\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Conclusion\"), \"\\n\", React.createElement(_components.p, null, \"Segment tree is used frequently for Range Queries or Subarray Queries, especially in competitive programming.\"), \"\\n\", React.createElement(_components.p, null, \"It reduces the time complexity for each range query to \", React.createElement(_components.strong, null, \"O( log n )\"), \" from \", React.createElement(_components.strong, null, \"O( n )\"), \", but uses \", React.createElement(_components.strong, null, \"O( n )\"), \" auxiliary space.\\nSo, when you have large number of range queries, you can easily use Segment tree to save time.\"), \"\\n\", React.createElement(_components.p, null, \"In this article, we saw the code to construct a Segment Tree in Rust. We will see Range Queries in the next article. Here is the optimized function for easy access\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-rust\"\n  }, \"fn cs(n:usize) ->usize{\\n    if n.count_ones() == 1 { return (n<<1)-1; }\\n    let k = 1<<(64 - n.leading_zeros());\\n    return (k<<1)-1;\\n}\\n\\nfn cons_st(arr:&Vec<usize>) -> Vec<usize> {\\n    let n = arr.len();\\n    let s = cs(n);\\n    let mut segment_tree = vec![0 as usize; s];\\n    cons_st_util(arr, &mut segment_tree, 0, n-1, 0);\\n    return segment_tree;\\n}\\n\\nfn cons_st_util(arr:&Vec<usize>, tree:&mut Vec<usize>, l:usize, h:usize, pos:usize){\\n    if h<l { return; }\\n    if h == l { tree[pos] = arr[l];return; }\\n    let mid = (h+l)/2;\\n    cons_st_util(arr, tree, l, mid, pos*2+1);\\n    cons_st_util(arr, tree, mid+1, h, pos*2+2);\\n\\n    // Here, you can change operation as per requirement\\n    // I am using product operator for reference\\n    tree[pos] = tree[pos*2+1]*tree[pos*2+2];\\n}\\n\\n\")), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"Thank You\")), \"\\n\", \"\\n\", React.createElement(SEO, {\n    title: \"Constructing a Segment Tree - Rust Programming\",\n    description: \"Segment tree is used for processing Range Queries in logarithmic time complexity. In this article, we will learn about Segment Tree, and also write a function to construct a Segment Tree in Rust Language.\"\n  }));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import React from \"react\";\nimport GATSBY_COMPILED_MDX from \"/home/naman/Desktop/rustp/website/pages/docs/5 Algorithms/5.1 Array Algorithms/Construct-Segment-Tree.mdx\";\nimport {graphql} from 'gatsby';\nexport const pageQuery = graphql`\n  query DocPageQuery($id: String!) {\n    mdx(id: { eq: $id }) {\n      fields {\n        pageType\n        title\n        editLink\n      }\n      tableOfContents\n    }\n  }\n`;\nfunction DocTemplate({children}) {\n  return children;\n}\nDocTemplate\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(DocTemplate, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","h1","a","div","p","h2","strong","ol","li","ul","pre","code","em","h3","_provideComponents","components","React","id","style","position","href","className","dangerouslySetInnerHTML","__html","SEO","title","description","MDXLayout","wrapper","DocTemplate","children","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}